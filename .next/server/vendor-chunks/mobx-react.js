"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mobx-react";
exports.ids = ["vendor-chunks/mobx-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/mobx-react/dist/mobxreact.cjs.development.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mobx-react/dist/mobxreact.cjs.development.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar mobx = __webpack_require__(/*! mobx */ \"(ssr)/./node_modules/mobx/dist/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar mobxReactLite = __webpack_require__(/*! mobx-react-lite */ \"(ssr)/./node_modules/mobx-react-lite/dist/index.js\");\n\nvar symbolId = 0;\n\nfunction createSymbol(name) {\n  if (typeof Symbol === \"function\") {\n    return Symbol(name);\n  }\n\n  var symbol = \"__$mobx-react \" + name + \" (\" + symbolId + \")\";\n  symbolId++;\n  return symbol;\n}\n\nvar createdSymbols = {};\nfunction newSymbol(name) {\n  if (!createdSymbols[name]) {\n    createdSymbols[name] = createSymbol(name);\n  }\n\n  return createdSymbols[name];\n}\nfunction shallowEqual(objA, objB) {\n  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n} // based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\n\n\nvar hoistBlackList = {\n  $$typeof: 1,\n  render: 1,\n  compare: 1,\n  type: 1,\n  childContextTypes: 1,\n  contextType: 1,\n  contextTypes: 1,\n  defaultProps: 1,\n  getDefaultProps: 1,\n  getDerivedStateFromError: 1,\n  getDerivedStateFromProps: 1,\n  mixins: 1,\n  displayName: 1,\n  propTypes: 1\n};\nfunction copyStaticProperties(base, target) {\n  var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));\n  Object.getOwnPropertyNames(base).forEach(function (key) {\n    if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n/**\r\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\r\n * @param target\r\n * @param prop\r\n * @param value\r\n */\n\nfunction setHiddenProp(target, prop, value) {\n  if (!Object.hasOwnProperty.call(target, prop)) {\n    Object.defineProperty(target, prop, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    target[prop] = value;\n  }\n}\n/**\r\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\r\n * and the handler provided by mobx-react\r\n */\n\nvar mobxMixins = /*#__PURE__*/newSymbol(\"patchMixins\");\nvar mobxPatchedDefinition = /*#__PURE__*/newSymbol(\"patchedDefinition\");\n\nfunction getMixins(target, methodName) {\n  var mixins = target[mobxMixins] = target[mobxMixins] || {};\n  var methodMixins = mixins[methodName] = mixins[methodName] || {};\n  methodMixins.locks = methodMixins.locks || 0;\n  methodMixins.methods = methodMixins.methods || [];\n  return methodMixins;\n}\n\nfunction wrapper(realMethod, mixins) {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n  mixins.locks++;\n\n  try {\n    var retVal;\n\n    if (realMethod !== undefined && realMethod !== null) {\n      retVal = realMethod.apply(this, args);\n    }\n\n    return retVal;\n  } finally {\n    mixins.locks--;\n\n    if (mixins.locks === 0) {\n      mixins.methods.forEach(function (mx) {\n        mx.apply(_this, args);\n      });\n    }\n  }\n}\n\nfunction wrapFunction(realMethod, mixins) {\n  var fn = function fn() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));\n  };\n\n  return fn;\n}\n\nfunction patch(target, methodName, mixinMethod) {\n  var mixins = getMixins(target, methodName);\n\n  if (mixins.methods.indexOf(mixinMethod) < 0) {\n    mixins.methods.push(mixinMethod);\n  }\n\n  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);\n\n  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n    // already patched definition, do not repatch\n    return;\n  }\n\n  var originalMethod = target[methodName];\n  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);\n  Object.defineProperty(target, methodName, newDefinition);\n}\n\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n  var _ref;\n\n  var wrappedFunc = wrapFunction(originalMethod, mixins);\n  return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get() {\n    return wrappedFunc;\n  }, _ref.set = function set(value) {\n    if (this === target) {\n      wrappedFunc = wrapFunction(value, mixins);\n    } else {\n      // when it is an instance of the prototype/a child prototype patch that particular case again separately\n      // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n      // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n      // as the method for the instance\n      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);\n      Object.defineProperty(this, methodName, newDefinition);\n    }\n  }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;\n}\n\nvar mobxAdminProperty = mobx.$mobx || \"$mobx\"; // BC\n\nvar mobxObserverProperty = /*#__PURE__*/newSymbol(\"isMobXReactObserver\");\nvar mobxIsUnmounted = /*#__PURE__*/newSymbol(\"isUnmounted\");\nvar skipRenderKey = /*#__PURE__*/newSymbol(\"skipRender\");\nvar isForcingUpdateKey = /*#__PURE__*/newSymbol(\"isForcingUpdate\");\nfunction makeClassComponentObserver(componentClass) {\n  var target = componentClass.prototype;\n\n  if (componentClass[mobxObserverProperty]) {\n    var displayName = getDisplayName(target);\n    console.warn(\"The provided component class (\" + displayName + \")\\n                has already been declared as an observer component.\");\n  } else {\n    componentClass[mobxObserverProperty] = true;\n  }\n\n  if (target.componentWillReact) {\n    throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n  }\n\n  if (componentClass[\"__proto__\"] !== React.PureComponent) {\n    if (!target.shouldComponentUpdate) {\n      target.shouldComponentUpdate = observerSCU;\n    } else if (target.shouldComponentUpdate !== observerSCU) {\n      // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n      throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n    }\n  } // this.props and this.state are made observable, just to make sure @computed fields that\n  // are defined inside the component, and which rely on state or props, re-compute if state or props change\n  // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n  // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n\n\n  makeObservableProp(target, \"props\");\n  makeObservableProp(target, \"state\");\n\n  if (componentClass.contextType) {\n    makeObservableProp(target, \"context\");\n  }\n\n  var originalRender = target.render;\n\n  if (typeof originalRender !== \"function\") {\n    var _displayName = getDisplayName(target);\n\n    throw new Error(\"[mobx-react] class component (\" + _displayName + \") is missing `render` method.\" + \"\\n`observer` requires `render` being a function defined on prototype.\" + \"\\n`render = () => {}` or `render = function() {}` is not supported.\");\n  }\n\n  target.render = function () {\n    this.render = mobxReactLite.isUsingStaticRendering() ? originalRender : createReactiveRender.call(this, originalRender);\n    return this.render();\n  };\n\n  patch(target, \"componentDidMount\", function () {\n    this[mobxIsUnmounted] = false;\n\n    if (!this.render[mobxAdminProperty]) {\n      // Reaction is re-created automatically during render, but a component can re-mount and skip render #3395.\n      // To re-create the reaction and re-subscribe to relevant observables we have to force an update.\n      React.Component.prototype.forceUpdate.call(this);\n    }\n  });\n  patch(target, \"componentWillUnmount\", function () {\n    if (mobxReactLite.isUsingStaticRendering()) {\n      return;\n    }\n\n    var reaction = this.render[mobxAdminProperty];\n\n    if (reaction) {\n      reaction.dispose(); // Forces reaction to be re-created on next render\n\n      this.render[mobxAdminProperty] = null;\n    } else {\n      // Render may have been hot-swapped and/or overridden by a subclass.\n      var _displayName2 = getDisplayName(this);\n\n      console.warn(\"The reactive render of an observer class component (\" + _displayName2 + \")\\n                was overridden after MobX attached. This may result in a memory leak if the\\n                overridden reactive render was not properly disposed.\");\n    }\n\n    this[mobxIsUnmounted] = true;\n  });\n  return componentClass;\n} // Generates a friendly name for debugging\n\nfunction getDisplayName(comp) {\n  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || \"<component>\";\n}\n\nfunction createReactiveRender(originalRender) {\n  var _this = this;\n\n  /**\r\n   * If props are shallowly modified, react will render anyway,\r\n   * so atom.reportChanged() should not result in yet another re-render\r\n   */\n  setHiddenProp(this, skipRenderKey, false);\n  /**\r\n   * forceUpdate will re-assign this.props. We don't want that to cause a loop,\r\n   * so detect these changes\r\n   */\n\n  setHiddenProp(this, isForcingUpdateKey, false);\n  var initialName = getDisplayName(this);\n  var boundOriginalRender = originalRender.bind(this);\n  var isRenderingPending = false;\n\n  var createReaction = function createReaction() {\n    var reaction = new mobx.Reaction(initialName + \".render()\", function () {\n      if (!isRenderingPending) {\n        // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.test.tsx)\n        // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n        // See #85 / Pull #44\n        isRenderingPending = true;\n\n        if (_this[mobxIsUnmounted] !== true) {\n          var hasError = true;\n\n          try {\n            setHiddenProp(_this, isForcingUpdateKey, true);\n\n            if (!_this[skipRenderKey]) {\n              React.Component.prototype.forceUpdate.call(_this);\n            }\n\n            hasError = false;\n          } finally {\n            setHiddenProp(_this, isForcingUpdateKey, false);\n\n            if (hasError) {\n              reaction.dispose(); // Forces reaction to be re-created on next render\n\n              _this.render[mobxAdminProperty] = null;\n            }\n          }\n        }\n      }\n    });\n    reaction[\"reactComponent\"] = _this;\n    return reaction;\n  };\n\n  function reactiveRender() {\n    var _reactiveRender$mobxA;\n\n    isRenderingPending = false; // Create reaction lazily to support re-mounting #3395\n\n    var reaction = (_reactiveRender$mobxA = reactiveRender[mobxAdminProperty]) != null ? _reactiveRender$mobxA : reactiveRender[mobxAdminProperty] = createReaction();\n    var exception = undefined;\n    var rendering = undefined;\n    reaction.track(function () {\n      try {\n        // TODO@major\n        // Optimization: replace with _allowStateChangesStart/End (not available in mobx@6.0.0)\n        rendering = mobx._allowStateChanges(false, boundOriginalRender);\n      } catch (e) {\n        exception = e;\n      }\n    });\n\n    if (exception) {\n      throw exception;\n    }\n\n    return rendering;\n  }\n\n  return reactiveRender;\n}\n\nfunction observerSCU(nextProps, nextState) {\n  if (mobxReactLite.isUsingStaticRendering()) {\n    console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n  } // update on any state changes (as is the default)\n\n\n  if (this.state !== nextState) {\n    return true;\n  } // update if props are shallowly not equal, inspired by PureRenderMixin\n  // we could return just 'false' here, and avoid the `skipRender` checks etc\n  // however, it is nicer if lifecycle events are triggered like usually,\n  // so we return true here if props are shallowly modified.\n\n\n  return !shallowEqual(this.props, nextProps);\n}\n\nfunction makeObservableProp(target, propName) {\n  var valueHolderKey = newSymbol(\"reactProp_\" + propName + \"_valueHolder\");\n  var atomHolderKey = newSymbol(\"reactProp_\" + propName + \"_atomHolder\");\n\n  function getAtom() {\n    if (!this[atomHolderKey]) {\n      setHiddenProp(this, atomHolderKey, mobx.createAtom(\"reactive \" + propName));\n    }\n\n    return this[atomHolderKey];\n  }\n\n  Object.defineProperty(target, propName, {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      var prevReadState = false; // Why this check? BC?\n      // @ts-expect-error\n\n      if (mobx._allowStateReadsStart && mobx._allowStateReadsEnd) {\n        prevReadState = mobx._allowStateReadsStart(true);\n      }\n\n      getAtom.call(this).reportObserved(); // Why this check? BC?\n      // @ts-expect-error\n\n      if (mobx._allowStateReadsStart && mobx._allowStateReadsEnd) {\n        mobx._allowStateReadsEnd(prevReadState);\n      }\n\n      return this[valueHolderKey];\n    },\n    set: function set(v) {\n      if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n        setHiddenProp(this, valueHolderKey, v);\n        setHiddenProp(this, skipRenderKey, true);\n        getAtom.call(this).reportChanged();\n        setHiddenProp(this, skipRenderKey, false);\n      } else {\n        setHiddenProp(this, valueHolderKey, v);\n      }\n    }\n  });\n}\n\n/**\r\n * Observer function / decorator\r\n */\n\nfunction observer(component) {\n  if (component[\"isMobxInjector\"] === true) {\n    console.warn(\"Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`\");\n  }\n\n  if (Object.prototype.isPrototypeOf.call(React.Component, component) || Object.prototype.isPrototypeOf.call(React.PureComponent, component)) {\n    // Class component\n    return makeClassComponentObserver(component);\n  } else {\n    // Function component\n    return mobxReactLite.observer(component);\n  }\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"children\"];\nvar MobXProviderContext = /*#__PURE__*/React__default.createContext({});\nfunction Provider(props) {\n  var children = props.children,\n      stores = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var parentValue = React__default.useContext(MobXProviderContext);\n  var mutableProviderRef = React__default.useRef(_extends({}, parentValue, stores));\n  var value = mutableProviderRef.current;\n\n  {\n    var newValue = _extends({}, value, stores); // spread in previous state for the context based stores\n\n\n    if (!shallowEqual(value, newValue)) {\n      throw new Error(\"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\");\n    }\n  }\n\n  return React__default.createElement(MobXProviderContext.Provider, {\n    value: value\n  }, children);\n}\nProvider.displayName = \"MobXProvider\";\n\n/**\r\n * Store Injection\r\n */\n\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n  // Support forward refs\n  var Injector = React__default.forwardRef(function (props, ref) {\n    var newProps = _extends({}, props);\n\n    var context = React__default.useContext(MobXProviderContext);\n    Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});\n\n    if (ref) {\n      newProps.ref = ref;\n    }\n\n    return React__default.createElement(component, newProps);\n  });\n  if (makeReactive) Injector = observer(Injector);\n  Injector[\"isMobxInjector\"] = true; // assigned late to suppress observer warning\n  // Static fields from component should be visible on the generated Injector\n\n  copyStaticProperties(component, Injector);\n  Injector[\"wrappedComponent\"] = component;\n  Injector.displayName = getInjectName(component, injectNames);\n  return Injector;\n}\n\nfunction getInjectName(component, injectNames) {\n  var displayName;\n  var componentName = component.displayName || component.name || component.constructor && component.constructor.name || \"Component\";\n  if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\";else displayName = \"inject(\" + componentName + \")\";\n  return displayName;\n}\n\nfunction grabStoresByName(storeNames) {\n  return function (baseStores, nextProps) {\n    storeNames.forEach(function (storeName) {\n      if (storeName in nextProps // prefer props over stores\n      ) return;\n      if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n      nextProps[storeName] = baseStores[storeName];\n    });\n    return nextProps;\n  };\n}\n/**\r\n * higher order component that injects stores to a child.\r\n * takes either a varargs list of strings, which are stores read from the context,\r\n * or a function that manually maps the available stores from the context to props:\r\n * storesToProps(mobxStores, props, context) => newProps\r\n */\n\n\nfunction inject() {\n  for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    storeNames[_key] = arguments[_key];\n  }\n\n  if (typeof arguments[0] === \"function\") {\n    var grabStoresFn = arguments[0];\n    return function (componentClass) {\n      return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);\n    };\n  } else {\n    return function (componentClass) {\n      return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join(\"-\"), false);\n    };\n  }\n}\n\nvar protoStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountProto\");\nvar instStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountInst\");\n\nfunction runDisposersOnWillUnmount() {\n  var _this = this;\n  [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function (propKeyOrFunction) {\n    var prop = typeof propKeyOrFunction === \"string\" ? _this[propKeyOrFunction] : propKeyOrFunction;\n\n    if (prop !== undefined && prop !== null) {\n      if (Array.isArray(prop)) prop.map(function (f) {\n        return f();\n      });else prop();\n    }\n  });\n}\n\nfunction disposeOnUnmount(target, propertyKeyOrFunction) {\n  if (Array.isArray(propertyKeyOrFunction)) {\n    return propertyKeyOrFunction.map(function (fn) {\n      return disposeOnUnmount(target, fn);\n    });\n  }\n\n  var c = Object.getPrototypeOf(target).constructor;\n  var c2 = Object.getPrototypeOf(target.constructor); // Special case for react-hot-loader\n\n  var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));\n\n  if (!(c === React__default.Component || c === React__default.PureComponent || c2 === React__default.Component || c2 === React__default.PureComponent || c3 === React__default.Component || c3 === React__default.PureComponent)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n  }\n\n  if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\" && !Array.isArray(propertyKeyOrFunction)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\");\n  } // decorator's target is the prototype, so it doesn't have any instance properties like props\n\n\n  var isDecorator = typeof propertyKeyOrFunction === \"string\"; // add property key / function we want run (disposed) to the store\n\n  var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];\n  var store = isDecorator ? // decorators are added to the prototype store\n  target[protoStoreKey] || (target[protoStoreKey] = []) : // functions are added to the instance store\n  target[instStoreKey] || (target[instStoreKey] = []);\n  store.push(propertyKeyOrFunction); // tweak the component class componentWillUnmount if not done already\n\n  if (!componentWasAlreadyModified) {\n    patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount);\n  } // return the disposer as is if invoked as a non decorator\n\n\n  if (typeof propertyKeyOrFunction !== \"string\") {\n    return propertyKeyOrFunction;\n  }\n}\n\nfunction createChainableTypeChecker(validator) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName) {\n    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n      rest[_key - 6] = arguments[_key];\n    }\n\n    return mobx.untracked(function () {\n      componentName = componentName || \"<<anonymous>>\";\n      propFullName = propFullName || propName;\n\n      if (props[propName] == null) {\n        if (isRequired) {\n          var actual = props[propName] === null ? \"null\" : \"undefined\";\n          return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n        }\n\n        return null;\n      } else {\n        // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n        return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));\n      }\n    });\n  }\n\n  var chainedCheckType = checkType.bind(null, false); // Add isRequired to satisfy Requirable\n\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n} // Copied from React.PropTypes\n\n\nfunction isSymbol(propType, propValue) {\n  // Native Symbol.\n  if (propType === \"symbol\") {\n    return true;\n  } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\n\n  if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n    return true;\n  } // Fallback for non-spec compliant Symbols which are polyfilled.\n\n\n  if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n    return true;\n  }\n\n  return false;\n} // Copied from React.PropTypes\n\n\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n\n  if (Array.isArray(propValue)) {\n    return \"array\";\n  }\n\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return \"object\";\n  }\n\n  if (isSymbol(propType, propValue)) {\n    return \"symbol\";\n  }\n\n  return propType;\n} // This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\n\n\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n\n  if (propType === \"object\") {\n    if (propValue instanceof Date) {\n      return \"date\";\n    } else if (propValue instanceof RegExp) {\n      return \"regexp\";\n    }\n  }\n\n  return propType;\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n    return mobx.untracked(function () {\n      if (allowNativeType) {\n        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n      }\n\n      var mobxChecker;\n\n      switch (mobxType) {\n        case \"Array\":\n          mobxChecker = mobx.isObservableArray;\n          break;\n\n        case \"Object\":\n          mobxChecker = mobx.isObservableObject;\n          break;\n\n        case \"Map\":\n          mobxChecker = mobx.isObservableMap;\n          break;\n\n        default:\n          throw new Error(\"Unexpected mobxType: \" + mobxType);\n      }\n\n      var propValue = props[propName];\n\n      if (!mobxChecker(propValue)) {\n        var preciseType = getPreciseType(propValue);\n        var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n        return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n      }\n\n      return null;\n    });\n  });\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n      rest[_key2 - 5] = arguments[_key2];\n    }\n\n    return mobx.untracked(function () {\n      if (typeof typeChecker !== \"function\") {\n        return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n      } else {\n        var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName, location, propFullName);\n        if (error instanceof Error) return error;\n        var propValue = props[propName];\n\n        for (var i = 0; i < propValue.length; i++) {\n          error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n          if (error instanceof Error) return error;\n        }\n\n        return null;\n      }\n    });\n  });\n}\n\nvar observableArray = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Object\");\nvar PropTypes = {\n  observableArray: observableArray,\n  observableArrayOf: observableArrayOf,\n  observableMap: observableMap,\n  observableObject: observableObject,\n  arrayOrObservableArray: arrayOrObservableArray,\n  arrayOrObservableArrayOf: arrayOrObservableArrayOf,\n  objectOrObservableObject: objectOrObservableObject\n};\n\nif (!React.Component) throw new Error(\"mobx-react requires React to be available\");\nif (!mobx.observable) throw new Error(\"mobx-react requires mobx to be available\");\n\nObject.defineProperty(exports, \"Observer\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.Observer;\n    }\n}));\nObject.defineProperty(exports, \"enableStaticRendering\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.enableStaticRendering;\n    }\n}));\nObject.defineProperty(exports, \"isUsingStaticRendering\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.isUsingStaticRendering;\n    }\n}));\nObject.defineProperty(exports, \"observerBatching\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.observerBatching;\n    }\n}));\nObject.defineProperty(exports, \"useAsObservableSource\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.useAsObservableSource;\n    }\n}));\nObject.defineProperty(exports, \"useLocalObservable\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.useLocalObservable;\n    }\n}));\nObject.defineProperty(exports, \"useLocalStore\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.useLocalStore;\n    }\n}));\nObject.defineProperty(exports, \"useObserver\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.useObserver;\n    }\n}));\nObject.defineProperty(exports, \"useStaticRendering\", ({\n    enumerable: true,\n    get: function () {\n        return mobxReactLite.useStaticRendering;\n    }\n}));\nexports.MobXProviderContext = MobXProviderContext;\nexports.PropTypes = PropTypes;\nexports.Provider = Provider;\nexports.disposeOnUnmount = disposeOnUnmount;\nexports.inject = inject;\nexports.observer = observer;\n//# sourceMappingURL=mobxreact.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC9kaXN0L21vYnhyZWFjdC5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQ0FBZ0M7O0FBRWhDLFdBQVcsbUJBQU8sQ0FBQyxxREFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0I7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBaUI7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1TUFBdU0sNEJBQTRCO0FBQ25POztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGtD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OUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixzREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhYnJpYy12aWRlby1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC9kaXN0L21vYnhyZWFjdC5janMuZGV2ZWxvcG1lbnQuanM/Mzc4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgbW9ieCA9IHJlcXVpcmUoJ21vYngnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIG1vYnhSZWFjdExpdGUgPSByZXF1aXJlKCdtb2J4LXJlYWN0LWxpdGUnKTtcblxudmFyIHN5bWJvbElkID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlU3ltYm9sKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBTeW1ib2wobmFtZSk7XG4gIH1cblxuICB2YXIgc3ltYm9sID0gXCJfXyRtb2J4LXJlYWN0IFwiICsgbmFtZSArIFwiIChcIiArIHN5bWJvbElkICsgXCIpXCI7XG4gIHN5bWJvbElkKys7XG4gIHJldHVybiBzeW1ib2w7XG59XG5cbnZhciBjcmVhdGVkU3ltYm9scyA9IHt9O1xuZnVuY3Rpb24gbmV3U3ltYm9sKG5hbWUpIHtcbiAgaWYgKCFjcmVhdGVkU3ltYm9sc1tuYW1lXSkge1xuICAgIGNyZWF0ZWRTeW1ib2xzW25hbWVdID0gY3JlYXRlU3ltYm9sKG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZWRTeW1ib2xzW25hbWVdO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgLy9Gcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59IC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmlkZ3dheS9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcblxuXG52YXIgaG9pc3RCbGFja0xpc3QgPSB7XG4gICQkdHlwZW9mOiAxLFxuICByZW5kZXI6IDEsXG4gIGNvbXBhcmU6IDEsXG4gIHR5cGU6IDEsXG4gIGNoaWxkQ29udGV4dFR5cGVzOiAxLFxuICBjb250ZXh0VHlwZTogMSxcbiAgY29udGV4dFR5cGVzOiAxLFxuICBkZWZhdWx0UHJvcHM6IDEsXG4gIGdldERlZmF1bHRQcm9wczogMSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiAxLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IDEsXG4gIG1peGluczogMSxcbiAgZGlzcGxheU5hbWU6IDEsXG4gIHByb3BUeXBlczogMVxufTtcbmZ1bmN0aW9uIGNvcHlTdGF0aWNQcm9wZXJ0aWVzKGJhc2UsIHRhcmdldCkge1xuICB2YXIgcHJvdG9Qcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSk7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJhc2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaG9pc3RCbGFja0xpc3Rba2V5XSAmJiBwcm90b1Byb3BzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIEhlbHBlciB0byBzZXQgYHByb3BgIHRvIGB0aGlzYCBhcyBub24tZW51bWVyYWJsZSAoaGlkZGVuIHByb3ApXHJcbiAqIEBwYXJhbSB0YXJnZXRcclxuICogQHBhcmFtIHByb3BcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRIaWRkZW5Qcm9wKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICB9XG59XG4vKipcclxuICogVXRpbGl0aWVzIGZvciBwYXRjaGluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgdG8gbWFrZSBzdXJlIEBkaXNwb3NlT25Vbm1vdW50IHdvcmtzIGNvcnJlY3RseSBpY20gd2l0aCB1c2VyIGRlZmluZWQgaG9va3NcclxuICogYW5kIHRoZSBoYW5kbGVyIHByb3ZpZGVkIGJ5IG1vYngtcmVhY3RcclxuICovXG5cbnZhciBtb2J4TWl4aW5zID0gLyojX19QVVJFX18qL25ld1N5bWJvbChcInBhdGNoTWl4aW5zXCIpO1xudmFyIG1vYnhQYXRjaGVkRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi9uZXdTeW1ib2woXCJwYXRjaGVkRGVmaW5pdGlvblwiKTtcblxuZnVuY3Rpb24gZ2V0TWl4aW5zKHRhcmdldCwgbWV0aG9kTmFtZSkge1xuICB2YXIgbWl4aW5zID0gdGFyZ2V0W21vYnhNaXhpbnNdID0gdGFyZ2V0W21vYnhNaXhpbnNdIHx8IHt9O1xuICB2YXIgbWV0aG9kTWl4aW5zID0gbWl4aW5zW21ldGhvZE5hbWVdID0gbWl4aW5zW21ldGhvZE5hbWVdIHx8IHt9O1xuICBtZXRob2RNaXhpbnMubG9ja3MgPSBtZXRob2RNaXhpbnMubG9ja3MgfHwgMDtcbiAgbWV0aG9kTWl4aW5zLm1ldGhvZHMgPSBtZXRob2RNaXhpbnMubWV0aG9kcyB8fCBbXTtcbiAgcmV0dXJuIG1ldGhvZE1peGlucztcbn1cblxuZnVuY3Rpb24gd3JhcHBlcihyZWFsTWV0aG9kLCBtaXhpbnMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICAvLyBsb2NrcyBhcmUgdXNlZCB0byBlbnN1cmUgdGhhdCBtaXhpbnMgYXJlIGludm9rZWQgb25seSBvbmNlIHBlciBpbnZvY2F0aW9uLCBldmVuIG9uIHJlY3Vyc2l2ZSBjYWxsc1xuICBtaXhpbnMubG9ja3MrKztcblxuICB0cnkge1xuICAgIHZhciByZXRWYWw7XG5cbiAgICBpZiAocmVhbE1ldGhvZCAhPT0gdW5kZWZpbmVkICYmIHJlYWxNZXRob2QgIT09IG51bGwpIHtcbiAgICAgIHJldFZhbCA9IHJlYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfSBmaW5hbGx5IHtcbiAgICBtaXhpbnMubG9ja3MtLTtcblxuICAgIGlmIChtaXhpbnMubG9ja3MgPT09IDApIHtcbiAgICAgIG1peGlucy5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG14KSB7XG4gICAgICAgIG14LmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24ocmVhbE1ldGhvZCwgbWl4aW5zKSB7XG4gIHZhciBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHdyYXBwZXIuY2FsbC5hcHBseSh3cmFwcGVyLCBbdGhpcywgcmVhbE1ldGhvZCwgbWl4aW5zXS5jb25jYXQoYXJncykpO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gcGF0Y2godGFyZ2V0LCBtZXRob2ROYW1lLCBtaXhpbk1ldGhvZCkge1xuICB2YXIgbWl4aW5zID0gZ2V0TWl4aW5zKHRhcmdldCwgbWV0aG9kTmFtZSk7XG5cbiAgaWYgKG1peGlucy5tZXRob2RzLmluZGV4T2YobWl4aW5NZXRob2QpIDwgMCkge1xuICAgIG1peGlucy5tZXRob2RzLnB1c2gobWl4aW5NZXRob2QpO1xuICB9XG5cbiAgdmFyIG9sZERlZmluaXRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbWV0aG9kTmFtZSk7XG5cbiAgaWYgKG9sZERlZmluaXRpb24gJiYgb2xkRGVmaW5pdGlvblttb2J4UGF0Y2hlZERlZmluaXRpb25dKSB7XG4gICAgLy8gYWxyZWFkeSBwYXRjaGVkIGRlZmluaXRpb24sIGRvIG5vdCByZXBhdGNoXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsTWV0aG9kID0gdGFyZ2V0W21ldGhvZE5hbWVdO1xuICB2YXIgbmV3RGVmaW5pdGlvbiA9IGNyZWF0ZURlZmluaXRpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBvbGREZWZpbml0aW9uID8gb2xkRGVmaW5pdGlvbi5lbnVtZXJhYmxlIDogdW5kZWZpbmVkLCBtaXhpbnMsIG9yaWdpbmFsTWV0aG9kKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbWV0aG9kTmFtZSwgbmV3RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBlbnVtZXJhYmxlLCBtaXhpbnMsIG9yaWdpbmFsTWV0aG9kKSB7XG4gIHZhciBfcmVmO1xuXG4gIHZhciB3cmFwcGVkRnVuYyA9IHdyYXBGdW5jdGlvbihvcmlnaW5hbE1ldGhvZCwgbWl4aW5zKTtcbiAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZlttb2J4UGF0Y2hlZERlZmluaXRpb25dID0gdHJ1ZSwgX3JlZi5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHdyYXBwZWRGdW5jO1xuICB9LCBfcmVmLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzID09PSB0YXJnZXQpIHtcbiAgICAgIHdyYXBwZWRGdW5jID0gd3JhcEZ1bmN0aW9uKHZhbHVlLCBtaXhpbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aGVuIGl0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBwcm90b3R5cGUvYSBjaGlsZCBwcm90b3R5cGUgcGF0Y2ggdGhhdCBwYXJ0aWN1bGFyIGNhc2UgYWdhaW4gc2VwYXJhdGVseVxuICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBzdG9yZSBzZXBhcmF0ZSB2YWx1ZXMgZGVwZW5kaW5nIG9uIHdldGhlciBpdCBpcyB0aGUgYWN0dWFsIGluc3RhbmNlLCB0aGUgcHJvdG90eXBlLCBldGNcbiAgICAgIC8vIGUuZy4gdGhlIG1ldGhvZCBmb3Igc3VwZXIgbWlnaHQgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBtZXRob2QgZm9yIHRoZSBwcm90b3R5cGUgd2hpY2ggbWlnaHQgYmUgbm90IHRoZSBzYW1lXG4gICAgICAvLyBhcyB0aGUgbWV0aG9kIGZvciB0aGUgaW5zdGFuY2VcbiAgICAgIHZhciBuZXdEZWZpbml0aW9uID0gY3JlYXRlRGVmaW5pdGlvbih0aGlzLCBtZXRob2ROYW1lLCBlbnVtZXJhYmxlLCBtaXhpbnMsIHZhbHVlKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBtZXRob2ROYW1lLCBuZXdEZWZpbml0aW9uKTtcbiAgICB9XG4gIH0sIF9yZWYuY29uZmlndXJhYmxlID0gdHJ1ZSwgX3JlZi5lbnVtZXJhYmxlID0gZW51bWVyYWJsZSwgX3JlZjtcbn1cblxudmFyIG1vYnhBZG1pblByb3BlcnR5ID0gbW9ieC4kbW9ieCB8fCBcIiRtb2J4XCI7IC8vIEJDXG5cbnZhciBtb2J4T2JzZXJ2ZXJQcm9wZXJ0eSA9IC8qI19fUFVSRV9fKi9uZXdTeW1ib2woXCJpc01vYlhSZWFjdE9ic2VydmVyXCIpO1xudmFyIG1vYnhJc1VubW91bnRlZCA9IC8qI19fUFVSRV9fKi9uZXdTeW1ib2woXCJpc1VubW91bnRlZFwiKTtcbnZhciBza2lwUmVuZGVyS2V5ID0gLyojX19QVVJFX18qL25ld1N5bWJvbChcInNraXBSZW5kZXJcIik7XG52YXIgaXNGb3JjaW5nVXBkYXRlS2V5ID0gLyojX19QVVJFX18qL25ld1N5bWJvbChcImlzRm9yY2luZ1VwZGF0ZVwiKTtcbmZ1bmN0aW9uIG1ha2VDbGFzc0NvbXBvbmVudE9ic2VydmVyKGNvbXBvbmVudENsYXNzKSB7XG4gIHZhciB0YXJnZXQgPSBjb21wb25lbnRDbGFzcy5wcm90b3R5cGU7XG5cbiAgaWYgKGNvbXBvbmVudENsYXNzW21vYnhPYnNlcnZlclByb3BlcnR5XSkge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKHRhcmdldCk7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIHByb3ZpZGVkIGNvbXBvbmVudCBjbGFzcyAoXCIgKyBkaXNwbGF5TmFtZSArIFwiKVxcbiAgICAgICAgICAgICAgICBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkIGFzIGFuIG9ic2VydmVyIGNvbXBvbmVudC5cIik7XG4gIH0gZWxzZSB7XG4gICAgY29tcG9uZW50Q2xhc3NbbW9ieE9ic2VydmVyUHJvcGVydHldID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0YXJnZXQuY29tcG9uZW50V2lsbFJlYWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbXBvbmVudFdpbGxSZWFjdCBsaWZlLWN5Y2xlIGV2ZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG4gIH1cblxuICBpZiAoY29tcG9uZW50Q2xhc3NbXCJfX3Byb3RvX19cIl0gIT09IFJlYWN0LlB1cmVDb21wb25lbnQpIHtcbiAgICBpZiAoIXRhcmdldC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgIHRhcmdldC5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBvYnNlcnZlclNDVTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09IG9ic2VydmVyU0NVKSB7XG4gICAgICAvLyBuLmIuIHVuZXF1YWwgY2hlY2ssIGluc3RlYWQgb2YgZXhpc3RlbmNlIGNoZWNrLCBhcyBAb2JzZXJ2ZXIgbWlnaHQgYmUgb24gc3VwZXJjbGFzcyBhcyB3ZWxsXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBpcyBub3QgYWxsb3dlZCB0byB1c2Ugc2hvdWxkQ29tcG9uZW50VXBkYXRlIGluIG9ic2VydmVyIGJhc2VkIGNvbXBvbmVudHMuXCIpO1xuICAgIH1cbiAgfSAvLyB0aGlzLnByb3BzIGFuZCB0aGlzLnN0YXRlIGFyZSBtYWRlIG9ic2VydmFibGUsIGp1c3QgdG8gbWFrZSBzdXJlIEBjb21wdXRlZCBmaWVsZHMgdGhhdFxuICAvLyBhcmUgZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCwgYW5kIHdoaWNoIHJlbHkgb24gc3RhdGUgb3IgcHJvcHMsIHJlLWNvbXB1dGUgaWYgc3RhdGUgb3IgcHJvcHMgY2hhbmdlXG4gIC8vIChvdGhlcndpc2UgdGhlIGNvbXB1dGVkIHdvdWxkbid0IHVwZGF0ZSBhbmQgYmVjb21lIHN0YWxlIG9uIHByb3BzIGNoYW5nZSwgc2luY2UgcHJvcHMgYXJlIG5vdCBvYnNlcnZhYmxlKVxuICAvLyBIb3dldmVyLCB0aGlzIHNvbHV0aW9uIGlzIG5vdCB3aXRob3V0IGl0J3Mgb3duIHByb2JsZW1zOiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtcmVhY3QvaXNzdWVzP3V0Zjg9JUUyJTlDJTkzJnE9aXMlM0Fpc3N1ZStsYWJlbCUzQW9ic2VydmFibGUtcHJvcHMtb3Itbm90K1xuXG5cbiAgbWFrZU9ic2VydmFibGVQcm9wKHRhcmdldCwgXCJwcm9wc1wiKTtcbiAgbWFrZU9ic2VydmFibGVQcm9wKHRhcmdldCwgXCJzdGF0ZVwiKTtcblxuICBpZiAoY29tcG9uZW50Q2xhc3MuY29udGV4dFR5cGUpIHtcbiAgICBtYWtlT2JzZXJ2YWJsZVByb3AodGFyZ2V0LCBcImNvbnRleHRcIik7XG4gIH1cblxuICB2YXIgb3JpZ2luYWxSZW5kZXIgPSB0YXJnZXQucmVuZGVyO1xuXG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxSZW5kZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBfZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZSh0YXJnZXQpO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYngtcmVhY3RdIGNsYXNzIGNvbXBvbmVudCAoXCIgKyBfZGlzcGxheU5hbWUgKyBcIikgaXMgbWlzc2luZyBgcmVuZGVyYCBtZXRob2QuXCIgKyBcIlxcbmBvYnNlcnZlcmAgcmVxdWlyZXMgYHJlbmRlcmAgYmVpbmcgYSBmdW5jdGlvbiBkZWZpbmVkIG9uIHByb3RvdHlwZS5cIiArIFwiXFxuYHJlbmRlciA9ICgpID0+IHt9YCBvciBgcmVuZGVyID0gZnVuY3Rpb24oKSB7fWAgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gIH1cblxuICB0YXJnZXQucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyID0gbW9ieFJlYWN0TGl0ZS5pc1VzaW5nU3RhdGljUmVuZGVyaW5nKCkgPyBvcmlnaW5hbFJlbmRlciA6IGNyZWF0ZVJlYWN0aXZlUmVuZGVyLmNhbGwodGhpcywgb3JpZ2luYWxSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIHBhdGNoKHRhcmdldCwgXCJjb21wb25lbnREaWRNb3VudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1ttb2J4SXNVbm1vdW50ZWRdID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMucmVuZGVyW21vYnhBZG1pblByb3BlcnR5XSkge1xuICAgICAgLy8gUmVhY3Rpb24gaXMgcmUtY3JlYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZW5kZXIsIGJ1dCBhIGNvbXBvbmVudCBjYW4gcmUtbW91bnQgYW5kIHNraXAgcmVuZGVyICMzMzk1LlxuICAgICAgLy8gVG8gcmUtY3JlYXRlIHRoZSByZWFjdGlvbiBhbmQgcmUtc3Vic2NyaWJlIHRvIHJlbGV2YW50IG9ic2VydmFibGVzIHdlIGhhdmUgdG8gZm9yY2UgYW4gdXBkYXRlLlxuICAgICAgUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHBhdGNoKHRhcmdldCwgXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1vYnhSZWFjdExpdGUuaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0aW9uID0gdGhpcy5yZW5kZXJbbW9ieEFkbWluUHJvcGVydHldO1xuXG4gICAgaWYgKHJlYWN0aW9uKSB7XG4gICAgICByZWFjdGlvbi5kaXNwb3NlKCk7IC8vIEZvcmNlcyByZWFjdGlvbiB0byBiZSByZS1jcmVhdGVkIG9uIG5leHQgcmVuZGVyXG5cbiAgICAgIHRoaXMucmVuZGVyW21vYnhBZG1pblByb3BlcnR5XSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlciBtYXkgaGF2ZSBiZWVuIGhvdC1zd2FwcGVkIGFuZC9vciBvdmVycmlkZGVuIGJ5IGEgc3ViY2xhc3MuXG4gICAgICB2YXIgX2Rpc3BsYXlOYW1lMiA9IGdldERpc3BsYXlOYW1lKHRoaXMpO1xuXG4gICAgICBjb25zb2xlLndhcm4oXCJUaGUgcmVhY3RpdmUgcmVuZGVyIG9mIGFuIG9ic2VydmVyIGNsYXNzIGNvbXBvbmVudCAoXCIgKyBfZGlzcGxheU5hbWUyICsgXCIpXFxuICAgICAgICAgICAgICAgIHdhcyBvdmVycmlkZGVuIGFmdGVyIE1vYlggYXR0YWNoZWQuIFRoaXMgbWF5IHJlc3VsdCBpbiBhIG1lbW9yeSBsZWFrIGlmIHRoZVxcbiAgICAgICAgICAgICAgICBvdmVycmlkZGVuIHJlYWN0aXZlIHJlbmRlciB3YXMgbm90IHByb3Blcmx5IGRpc3Bvc2VkLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzW21vYnhJc1VubW91bnRlZF0gPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufSAvLyBHZW5lcmF0ZXMgYSBmcmllbmRseSBuYW1lIGZvciBkZWJ1Z2dpbmdcblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoY29tcCkge1xuICByZXR1cm4gY29tcC5kaXNwbGF5TmFtZSB8fCBjb21wLm5hbWUgfHwgY29tcC5jb25zdHJ1Y3RvciAmJiAoY29tcC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb21wLmNvbnN0cnVjdG9yLm5hbWUpIHx8IFwiPGNvbXBvbmVudD5cIjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVSZW5kZXIob3JpZ2luYWxSZW5kZXIpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICAvKipcclxuICAgKiBJZiBwcm9wcyBhcmUgc2hhbGxvd2x5IG1vZGlmaWVkLCByZWFjdCB3aWxsIHJlbmRlciBhbnl3YXksXHJcbiAgICogc28gYXRvbS5yZXBvcnRDaGFuZ2VkKCkgc2hvdWxkIG5vdCByZXN1bHQgaW4geWV0IGFub3RoZXIgcmUtcmVuZGVyXHJcbiAgICovXG4gIHNldEhpZGRlblByb3AodGhpcywgc2tpcFJlbmRlcktleSwgZmFsc2UpO1xuICAvKipcclxuICAgKiBmb3JjZVVwZGF0ZSB3aWxsIHJlLWFzc2lnbiB0aGlzLnByb3BzLiBXZSBkb24ndCB3YW50IHRoYXQgdG8gY2F1c2UgYSBsb29wLFxyXG4gICAqIHNvIGRldGVjdCB0aGVzZSBjaGFuZ2VzXHJcbiAgICovXG5cbiAgc2V0SGlkZGVuUHJvcCh0aGlzLCBpc0ZvcmNpbmdVcGRhdGVLZXksIGZhbHNlKTtcbiAgdmFyIGluaXRpYWxOYW1lID0gZ2V0RGlzcGxheU5hbWUodGhpcyk7XG4gIHZhciBib3VuZE9yaWdpbmFsUmVuZGVyID0gb3JpZ2luYWxSZW5kZXIuYmluZCh0aGlzKTtcbiAgdmFyIGlzUmVuZGVyaW5nUGVuZGluZyA9IGZhbHNlO1xuXG4gIHZhciBjcmVhdGVSZWFjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWN0aW9uKCkge1xuICAgIHZhciByZWFjdGlvbiA9IG5ldyBtb2J4LlJlYWN0aW9uKGluaXRpYWxOYW1lICsgXCIucmVuZGVyKClcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc1JlbmRlcmluZ1BlbmRpbmcpIHtcbiAgICAgICAgLy8gTi5CLiBHZXR0aW5nIGhlcmUgKmJlZm9yZSBtb3VudGluZyogbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBoYXMgc2lkZSBlZmZlY3RzIChzZWUgdGhlIHJlbGV2YW50IHRlc3QgaW4gbWlzYy50ZXN0LnRzeClcbiAgICAgICAgLy8gVGhpcyB1bmlkaW9tYXRpYyBSZWFjdCB1c2FnZSBidXQgUmVhY3Qgd2lsbCBjb3JyZWN0bHkgd2FybiBhYm91dCB0aGlzIHNvIHdlIGNvbnRpbnVlIGFzIHVzdWFsXG4gICAgICAgIC8vIFNlZSAjODUgLyBQdWxsICM0NFxuICAgICAgICBpc1JlbmRlcmluZ1BlbmRpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChfdGhpc1ttb2J4SXNVbm1vdW50ZWRdICE9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGhhc0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRIaWRkZW5Qcm9wKF90aGlzLCBpc0ZvcmNpbmdVcGRhdGVLZXksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoIV90aGlzW3NraXBSZW5kZXJLZXldKSB7XG4gICAgICAgICAgICAgIFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUuY2FsbChfdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldEhpZGRlblByb3AoX3RoaXMsIGlzRm9yY2luZ1VwZGF0ZUtleSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVhY3Rpb24uZGlzcG9zZSgpOyAvLyBGb3JjZXMgcmVhY3Rpb24gdG8gYmUgcmUtY3JlYXRlZCBvbiBuZXh0IHJlbmRlclxuXG4gICAgICAgICAgICAgIF90aGlzLnJlbmRlclttb2J4QWRtaW5Qcm9wZXJ0eV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlYWN0aW9uW1wicmVhY3RDb21wb25lbnRcIl0gPSBfdGhpcztcbiAgICByZXR1cm4gcmVhY3Rpb247XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmVSZW5kZXIoKSB7XG4gICAgdmFyIF9yZWFjdGl2ZVJlbmRlciRtb2J4QTtcblxuICAgIGlzUmVuZGVyaW5nUGVuZGluZyA9IGZhbHNlOyAvLyBDcmVhdGUgcmVhY3Rpb24gbGF6aWx5IHRvIHN1cHBvcnQgcmUtbW91bnRpbmcgIzMzOTVcblxuICAgIHZhciByZWFjdGlvbiA9IChfcmVhY3RpdmVSZW5kZXIkbW9ieEEgPSByZWFjdGl2ZVJlbmRlclttb2J4QWRtaW5Qcm9wZXJ0eV0pICE9IG51bGwgPyBfcmVhY3RpdmVSZW5kZXIkbW9ieEEgOiByZWFjdGl2ZVJlbmRlclttb2J4QWRtaW5Qcm9wZXJ0eV0gPSBjcmVhdGVSZWFjdGlvbigpO1xuICAgIHZhciBleGNlcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHJlbmRlcmluZyA9IHVuZGVmaW5lZDtcbiAgICByZWFjdGlvbi50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUT0RPQG1ham9yXG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogcmVwbGFjZSB3aXRoIF9hbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0L0VuZCAobm90IGF2YWlsYWJsZSBpbiBtb2J4QDYuMC4wKVxuICAgICAgICByZW5kZXJpbmcgPSBtb2J4Ll9hbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgYm91bmRPcmlnaW5hbFJlbmRlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmluZztcbiAgfVxuXG4gIHJldHVybiByZWFjdGl2ZVJlbmRlcjtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZXJTQ1UobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgaWYgKG1vYnhSZWFjdExpdGUuaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYngtcmVhY3RdIEl0IHNlZW1zIHRoYXQgYSByZS1yZW5kZXJpbmcgb2YgYSBSZWFjdCBjb21wb25lbnQgaXMgdHJpZ2dlcmVkIHdoaWxlIGluIHN0YXRpYyAoc2VydmVyLXNpZGUpIG1vZGUuIFBsZWFzZSBtYWtlIHN1cmUgY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb25seSBvbmNlIHNlcnZlci1zaWRlLlwiKTtcbiAgfSAvLyB1cGRhdGUgb24gYW55IHN0YXRlIGNoYW5nZXMgKGFzIGlzIHRoZSBkZWZhdWx0KVxuXG5cbiAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHVwZGF0ZSBpZiBwcm9wcyBhcmUgc2hhbGxvd2x5IG5vdCBlcXVhbCwgaW5zcGlyZWQgYnkgUHVyZVJlbmRlck1peGluXG4gIC8vIHdlIGNvdWxkIHJldHVybiBqdXN0ICdmYWxzZScgaGVyZSwgYW5kIGF2b2lkIHRoZSBgc2tpcFJlbmRlcmAgY2hlY2tzIGV0Y1xuICAvLyBob3dldmVyLCBpdCBpcyBuaWNlciBpZiBsaWZlY3ljbGUgZXZlbnRzIGFyZSB0cmlnZ2VyZWQgbGlrZSB1c3VhbGx5LFxuICAvLyBzbyB3ZSByZXR1cm4gdHJ1ZSBoZXJlIGlmIHByb3BzIGFyZSBzaGFsbG93bHkgbW9kaWZpZWQuXG5cblxuICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xufVxuXG5mdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZVByb3AodGFyZ2V0LCBwcm9wTmFtZSkge1xuICB2YXIgdmFsdWVIb2xkZXJLZXkgPSBuZXdTeW1ib2woXCJyZWFjdFByb3BfXCIgKyBwcm9wTmFtZSArIFwiX3ZhbHVlSG9sZGVyXCIpO1xuICB2YXIgYXRvbUhvbGRlcktleSA9IG5ld1N5bWJvbChcInJlYWN0UHJvcF9cIiArIHByb3BOYW1lICsgXCJfYXRvbUhvbGRlclwiKTtcblxuICBmdW5jdGlvbiBnZXRBdG9tKCkge1xuICAgIGlmICghdGhpc1thdG9tSG9sZGVyS2V5XSkge1xuICAgICAgc2V0SGlkZGVuUHJvcCh0aGlzLCBhdG9tSG9sZGVyS2V5LCBtb2J4LmNyZWF0ZUF0b20oXCJyZWFjdGl2ZSBcIiArIHByb3BOYW1lKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbYXRvbUhvbGRlcktleV07XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wTmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZXZSZWFkU3RhdGUgPSBmYWxzZTsgLy8gV2h5IHRoaXMgY2hlY2s/IEJDP1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuXG4gICAgICBpZiAobW9ieC5fYWxsb3dTdGF0ZVJlYWRzU3RhcnQgJiYgbW9ieC5fYWxsb3dTdGF0ZVJlYWRzRW5kKSB7XG4gICAgICAgIHByZXZSZWFkU3RhdGUgPSBtb2J4Ll9hbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZ2V0QXRvbS5jYWxsKHRoaXMpLnJlcG9ydE9ic2VydmVkKCk7IC8vIFdoeSB0aGlzIGNoZWNrPyBCQz9cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgICAgaWYgKG1vYnguX2FsbG93U3RhdGVSZWFkc1N0YXJ0ICYmIG1vYnguX2FsbG93U3RhdGVSZWFkc0VuZCkge1xuICAgICAgICBtb2J4Ll9hbGxvd1N0YXRlUmVhZHNFbmQocHJldlJlYWRTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW3ZhbHVlSG9sZGVyS2V5XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIGlmICghdGhpc1tpc0ZvcmNpbmdVcGRhdGVLZXldICYmICFzaGFsbG93RXF1YWwodGhpc1t2YWx1ZUhvbGRlcktleV0sIHYpKSB7XG4gICAgICAgIHNldEhpZGRlblByb3AodGhpcywgdmFsdWVIb2xkZXJLZXksIHYpO1xuICAgICAgICBzZXRIaWRkZW5Qcm9wKHRoaXMsIHNraXBSZW5kZXJLZXksIHRydWUpO1xuICAgICAgICBnZXRBdG9tLmNhbGwodGhpcykucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICBzZXRIaWRkZW5Qcm9wKHRoaXMsIHNraXBSZW5kZXJLZXksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEhpZGRlblByb3AodGhpcywgdmFsdWVIb2xkZXJLZXksIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBPYnNlcnZlciBmdW5jdGlvbiAvIGRlY29yYXRvclxyXG4gKi9cblxuZnVuY3Rpb24gb2JzZXJ2ZXIoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnRbXCJpc01vYnhJbmplY3RvclwiXSA9PT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIk1vYnggb2JzZXJ2ZXI6IFlvdSBhcmUgdHJ5aW5nIHRvIHVzZSBgb2JzZXJ2ZXJgIG9uIGEgY29tcG9uZW50IHRoYXQgYWxyZWFkeSBoYXMgYGluamVjdGAuIFBsZWFzZSBhcHBseSBgb2JzZXJ2ZXJgIGJlZm9yZSBhcHBseWluZyBgaW5qZWN0YFwiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChSZWFjdC5Db21wb25lbnQsIGNvbXBvbmVudCkgfHwgT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoUmVhY3QuUHVyZUNvbXBvbmVudCwgY29tcG9uZW50KSkge1xuICAgIC8vIENsYXNzIGNvbXBvbmVudFxuICAgIHJldHVybiBtYWtlQ2xhc3NDb21wb25lbnRPYnNlcnZlcihjb21wb25lbnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudFxuICAgIHJldHVybiBtb2J4UmVhY3RMaXRlLm9ic2VydmVyKGNvbXBvbmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiXTtcbnZhciBNb2JYUHJvdmlkZXJDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe30pO1xuZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBzdG9yZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcblxuICB2YXIgcGFyZW50VmFsdWUgPSBSZWFjdF9fZGVmYXVsdC51c2VDb250ZXh0KE1vYlhQcm92aWRlckNvbnRleHQpO1xuICB2YXIgbXV0YWJsZVByb3ZpZGVyUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKF9leHRlbmRzKHt9LCBwYXJlbnRWYWx1ZSwgc3RvcmVzKSk7XG4gIHZhciB2YWx1ZSA9IG11dGFibGVQcm92aWRlclJlZi5jdXJyZW50O1xuXG4gIHtcbiAgICB2YXIgbmV3VmFsdWUgPSBfZXh0ZW5kcyh7fSwgdmFsdWUsIHN0b3Jlcyk7IC8vIHNwcmVhZCBpbiBwcmV2aW91cyBzdGF0ZSBmb3IgdGhlIGNvbnRleHQgYmFzZWQgc3RvcmVzXG5cblxuICAgIGlmICghc2hhbGxvd0VxdWFsKHZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vYlggUHJvdmlkZXI6IFRoZSBzZXQgb2YgcHJvdmlkZWQgc3RvcmVzIGhhcyBjaGFuZ2VkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1yZWFjdCN0aGUtc2V0LW9mLXByb3ZpZGVkLXN0b3Jlcy1oYXMtY2hhbmdlZC1lcnJvci5cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTW9iWFByb3ZpZGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5Qcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiTW9iWFByb3ZpZGVyXCI7XG5cbi8qKlxyXG4gKiBTdG9yZSBJbmplY3Rpb25cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSW5qZWN0b3IoZ3JhYlN0b3Jlc0ZuLCBjb21wb25lbnQsIGluamVjdE5hbWVzLCBtYWtlUmVhY3RpdmUpIHtcbiAgLy8gU3VwcG9ydCBmb3J3YXJkIHJlZnNcbiAgdmFyIEluamVjdG9yID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHZhciBuZXdQcm9wcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG5cbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTW9iWFByb3ZpZGVyQ29udGV4dCk7XG4gICAgT2JqZWN0LmFzc2lnbihuZXdQcm9wcywgZ3JhYlN0b3Jlc0ZuKGNvbnRleHQgfHwge30sIG5ld1Byb3BzKSB8fCB7fSk7XG5cbiAgICBpZiAocmVmKSB7XG4gICAgICBuZXdQcm9wcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBuZXdQcm9wcyk7XG4gIH0pO1xuICBpZiAobWFrZVJlYWN0aXZlKSBJbmplY3RvciA9IG9ic2VydmVyKEluamVjdG9yKTtcbiAgSW5qZWN0b3JbXCJpc01vYnhJbmplY3RvclwiXSA9IHRydWU7IC8vIGFzc2lnbmVkIGxhdGUgdG8gc3VwcHJlc3Mgb2JzZXJ2ZXIgd2FybmluZ1xuICAvLyBTdGF0aWMgZmllbGRzIGZyb20gY29tcG9uZW50IHNob3VsZCBiZSB2aXNpYmxlIG9uIHRoZSBnZW5lcmF0ZWQgSW5qZWN0b3JcblxuICBjb3B5U3RhdGljUHJvcGVydGllcyhjb21wb25lbnQsIEluamVjdG9yKTtcbiAgSW5qZWN0b3JbXCJ3cmFwcGVkQ29tcG9uZW50XCJdID0gY29tcG9uZW50O1xuICBJbmplY3Rvci5kaXNwbGF5TmFtZSA9IGdldEluamVjdE5hbWUoY29tcG9uZW50LCBpbmplY3ROYW1lcyk7XG4gIHJldHVybiBJbmplY3Rvcjtcbn1cblxuZnVuY3Rpb24gZ2V0SW5qZWN0TmFtZShjb21wb25lbnQsIGluamVjdE5hbWVzKSB7XG4gIHZhciBkaXNwbGF5TmFtZTtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Lm5hbWUgfHwgY29tcG9uZW50LmNvbnN0cnVjdG9yICYmIGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XG4gIGlmIChpbmplY3ROYW1lcykgZGlzcGxheU5hbWUgPSBcImluamVjdC13aXRoLVwiICsgaW5qZWN0TmFtZXMgKyBcIihcIiArIGNvbXBvbmVudE5hbWUgKyBcIilcIjtlbHNlIGRpc3BsYXlOYW1lID0gXCJpbmplY3QoXCIgKyBjb21wb25lbnROYW1lICsgXCIpXCI7XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ3JhYlN0b3Jlc0J5TmFtZShzdG9yZU5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYmFzZVN0b3JlcywgbmV4dFByb3BzKSB7XG4gICAgc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgIGlmIChzdG9yZU5hbWUgaW4gbmV4dFByb3BzIC8vIHByZWZlciBwcm9wcyBvdmVyIHN0b3Jlc1xuICAgICAgKSByZXR1cm47XG4gICAgICBpZiAoIShzdG9yZU5hbWUgaW4gYmFzZVN0b3JlcykpIHRocm93IG5ldyBFcnJvcihcIk1vYlggaW5qZWN0b3I6IFN0b3JlICdcIiArIHN0b3JlTmFtZSArIFwiJyBpcyBub3QgYXZhaWxhYmxlISBNYWtlIHN1cmUgaXQgaXMgcHJvdmlkZWQgYnkgc29tZSBQcm92aWRlclwiKTtcbiAgICAgIG5leHRQcm9wc1tzdG9yZU5hbWVdID0gYmFzZVN0b3Jlc1tzdG9yZU5hbWVdO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0UHJvcHM7XG4gIH07XG59XG4vKipcclxuICogaGlnaGVyIG9yZGVyIGNvbXBvbmVudCB0aGF0IGluamVjdHMgc3RvcmVzIHRvIGEgY2hpbGQuXHJcbiAqIHRha2VzIGVpdGhlciBhIHZhcmFyZ3MgbGlzdCBvZiBzdHJpbmdzLCB3aGljaCBhcmUgc3RvcmVzIHJlYWQgZnJvbSB0aGUgY29udGV4dCxcclxuICogb3IgYSBmdW5jdGlvbiB0aGF0IG1hbnVhbGx5IG1hcHMgdGhlIGF2YWlsYWJsZSBzdG9yZXMgZnJvbSB0aGUgY29udGV4dCB0byBwcm9wczpcclxuICogc3RvcmVzVG9Qcm9wcyhtb2J4U3RvcmVzLCBwcm9wcywgY29udGV4dCkgPT4gbmV3UHJvcHNcclxuICovXG5cblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RvcmVOYW1lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdG9yZU5hbWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBncmFiU3RvcmVzRm4gPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN0b3JlSW5qZWN0b3IoZ3JhYlN0b3Jlc0ZuLCBjb21wb25lbnRDbGFzcywgZ3JhYlN0b3Jlc0ZuLm5hbWUsIHRydWUpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN0b3JlSW5qZWN0b3IoZ3JhYlN0b3Jlc0J5TmFtZShzdG9yZU5hbWVzKSwgY29tcG9uZW50Q2xhc3MsIHN0b3JlTmFtZXMuam9pbihcIi1cIiksIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBwcm90b1N0b3JlS2V5ID0gLyojX19QVVJFX18qL25ld1N5bWJvbChcImRpc3Bvc2VPblVubW91bnRQcm90b1wiKTtcbnZhciBpbnN0U3RvcmVLZXkgPSAvKiNfX1BVUkVfXyovbmV3U3ltYm9sKFwiZGlzcG9zZU9uVW5tb3VudEluc3RcIik7XG5cbmZ1bmN0aW9uIHJ1bkRpc3Bvc2Vyc09uV2lsbFVubW91bnQoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIFtdLmNvbmNhdCh0aGlzW3Byb3RvU3RvcmVLZXldIHx8IFtdLCB0aGlzW2luc3RTdG9yZUtleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHByb3BLZXlPckZ1bmN0aW9uKSB7XG4gICAgdmFyIHByb3AgPSB0eXBlb2YgcHJvcEtleU9yRnVuY3Rpb24gPT09IFwic3RyaW5nXCIgPyBfdGhpc1twcm9wS2V5T3JGdW5jdGlvbl0gOiBwcm9wS2V5T3JGdW5jdGlvbjtcblxuICAgIGlmIChwcm9wICE9PSB1bmRlZmluZWQgJiYgcHJvcCAhPT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHByb3AubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgICB9KTtlbHNlIHByb3AoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwb3NlT25Vbm1vdW50KHRhcmdldCwgcHJvcGVydHlLZXlPckZ1bmN0aW9uKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5S2V5T3JGdW5jdGlvbikpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXlPckZ1bmN0aW9uLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBkaXNwb3NlT25Vbm1vdW50KHRhcmdldCwgZm4pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KS5jb25zdHJ1Y3RvcjtcbiAgdmFyIGMyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldC5jb25zdHJ1Y3Rvcik7IC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVhY3QtaG90LWxvYWRlclxuXG4gIHZhciBjMyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSk7XG5cbiAgaWYgKCEoYyA9PT0gUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50IHx8IGMgPT09IFJlYWN0X19kZWZhdWx0LlB1cmVDb21wb25lbnQgfHwgYzIgPT09IFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCB8fCBjMiA9PT0gUmVhY3RfX2RlZmF1bHQuUHVyZUNvbXBvbmVudCB8fCBjMyA9PT0gUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50IHx8IGMzID09PSBSZWFjdF9fZGVmYXVsdC5QdXJlQ29tcG9uZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LXJlYWN0XSBkaXNwb3NlT25Vbm1vdW50IG9ubHkgc3VwcG9ydHMgZGlyZWN0IHN1YmNsYXNzZXMgb2YgUmVhY3QuQ29tcG9uZW50IG9yIFJlYWN0LlB1cmVDb21wb25lbnQuXCIpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wZXJ0eUtleU9yRnVuY3Rpb24gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByb3BlcnR5S2V5T3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiICYmICFBcnJheS5pc0FycmF5KHByb3BlcnR5S2V5T3JGdW5jdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdF0gZGlzcG9zZU9uVW5tb3VudCBvbmx5IHdvcmtzIGlmIHRoZSBwYXJhbWV0ZXIgaXMgZWl0aGVyIGEgcHJvcGVydHkga2V5IG9yIGEgZnVuY3Rpb24uXCIpO1xuICB9IC8vIGRlY29yYXRvcidzIHRhcmdldCBpcyB0aGUgcHJvdG90eXBlLCBzbyBpdCBkb2Vzbid0IGhhdmUgYW55IGluc3RhbmNlIHByb3BlcnRpZXMgbGlrZSBwcm9wc1xuXG5cbiAgdmFyIGlzRGVjb3JhdG9yID0gdHlwZW9mIHByb3BlcnR5S2V5T3JGdW5jdGlvbiA9PT0gXCJzdHJpbmdcIjsgLy8gYWRkIHByb3BlcnR5IGtleSAvIGZ1bmN0aW9uIHdlIHdhbnQgcnVuIChkaXNwb3NlZCkgdG8gdGhlIHN0b3JlXG5cbiAgdmFyIGNvbXBvbmVudFdhc0FscmVhZHlNb2RpZmllZCA9ICEhdGFyZ2V0W3Byb3RvU3RvcmVLZXldIHx8ICEhdGFyZ2V0W2luc3RTdG9yZUtleV07XG4gIHZhciBzdG9yZSA9IGlzRGVjb3JhdG9yID8gLy8gZGVjb3JhdG9ycyBhcmUgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBzdG9yZVxuICB0YXJnZXRbcHJvdG9TdG9yZUtleV0gfHwgKHRhcmdldFtwcm90b1N0b3JlS2V5XSA9IFtdKSA6IC8vIGZ1bmN0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIGluc3RhbmNlIHN0b3JlXG4gIHRhcmdldFtpbnN0U3RvcmVLZXldIHx8ICh0YXJnZXRbaW5zdFN0b3JlS2V5XSA9IFtdKTtcbiAgc3RvcmUucHVzaChwcm9wZXJ0eUtleU9yRnVuY3Rpb24pOyAvLyB0d2VhayB0aGUgY29tcG9uZW50IGNsYXNzIGNvbXBvbmVudFdpbGxVbm1vdW50IGlmIG5vdCBkb25lIGFscmVhZHlcblxuICBpZiAoIWNvbXBvbmVudFdhc0FscmVhZHlNb2RpZmllZCkge1xuICAgIHBhdGNoKHRhcmdldCwgXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLCBydW5EaXNwb3NlcnNPbldpbGxVbm1vdW50KTtcbiAgfSAvLyByZXR1cm4gdGhlIGRpc3Bvc2VyIGFzIGlzIGlmIGludm9rZWQgYXMgYSBub24gZGVjb3JhdG9yXG5cblxuICBpZiAodHlwZW9mIHByb3BlcnR5S2V5T3JGdW5jdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleU9yRnVuY3Rpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdG9yKSB7XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gNiA/IF9sZW4gLSA2IDogMCksIF9rZXkgPSA2OyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSA2XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9ieC51bnRyYWNrZWQoZnVuY3Rpb24gKCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgXCI8PGFub255bW91cz4+XCI7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIHZhciBhY3R1YWwgPSBwcm9wc1twcm9wTmFtZV0gPT09IG51bGwgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIlRoZSBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBcIiArIFwiaW4gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgXCIgKyBhY3R1YWwgKyBcImAuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlIHJlc3QgYXJnIGlzIG5lY2Vzc2FyeSBmb3Igc29tZSBSZWFjdCBpbnRlcm5hbHMgLSBmYWlscyB0ZXN0cyBvdGhlcndpc2VcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvci5hcHBseSh2b2lkIDAsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTsgLy8gQWRkIGlzUmVxdWlyZWQgdG8gc2F0aXNmeSBSZXF1aXJhYmxlXG5cbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufSAvLyBDb3BpZWQgZnJvbSBSZWFjdC5Qcm9wVHlwZXNcblxuXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIGlmIChwcm9wVHlwZSA9PT0gXCJzeW1ib2xcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG5cblxuICBpZiAocHJvcFZhbHVlW1wiQEB0b1N0cmluZ1RhZ1wiXSA9PT0gXCJTeW1ib2xcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cblxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIENvcGllZCBmcm9tIFJlYWN0LlByb3BUeXBlc1xuXG5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG5cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgfVxuXG4gIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgIHJldHVybiBcInN5bWJvbFwiO1xuICB9XG5cbiAgcmV0dXJuIHByb3BUeXBlO1xufSAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBDb3BpZWQgZnJvbSBSZWFjdC5Qcm9wVHlwZXNcblxuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblxuICBpZiAocHJvcFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gXCJyZWdleHBcIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IoYWxsb3dOYXRpdmVUeXBlLCBtb2J4VHlwZSkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHJldHVybiBtb2J4LnVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYWxsb3dOYXRpdmVUeXBlKSB7XG4gICAgICAgIGlmIChnZXRQcm9wVHlwZShwcm9wc1twcm9wTmFtZV0pID09PSBtb2J4VHlwZS50b0xvd2VyQ2FzZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vYnhDaGVja2VyO1xuXG4gICAgICBzd2l0Y2ggKG1vYnhUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgIG1vYnhDaGVja2VyID0gbW9ieC5pc09ic2VydmFibGVBcnJheTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgbW9ieENoZWNrZXIgPSBtb2J4LmlzT2JzZXJ2YWJsZU9iamVjdDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTWFwXCI6XG4gICAgICAgICAgbW9ieENoZWNrZXIgPSBtb2J4LmlzT2JzZXJ2YWJsZU1hcDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbW9ieFR5cGU6IFwiICsgbW9ieFR5cGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgICBpZiAoIW1vYnhDaGVja2VyKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIG5hdGl2ZVR5cGVFeHBlY3RhdGlvbk1lc3NhZ2UgPSBhbGxvd05hdGl2ZVR5cGUgPyBcIiBvciBqYXZhc2NyaXB0IGBcIiArIG1vYnhUeXBlLnRvTG93ZXJDYXNlKCkgKyBcImBcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgcHJlY2lzZVR5cGUgKyBcImAgc3VwcGxpZWQgdG9cIiArIFwiIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBtb2J4Lk9ic2VydmFibGVcIiArIG1vYnhUeXBlICsgXCJgXCIgKyBuYXRpdmVUeXBlRXhwZWN0YXRpb25NZXNzYWdlICsgXCIuXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBcnJheU9mVHlwZUNoZWNrZXIoYWxsb3dOYXRpdmVUeXBlLCB0eXBlQ2hlY2tlcikge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDUgPyBfbGVuMiAtIDUgOiAwKSwgX2tleTIgPSA1OyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICByZXN0W19rZXkyIC0gNV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2J4LnVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIlByb3BlcnR5IGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCBoYXMgXCIgKyBcImludmFsaWQgUHJvcFR5cGUgbm90YXRpb24uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcihhbGxvd05hdGl2ZVR5cGUsIFwiQXJyYXlcIikocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnJvcjtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVycm9yID0gdHlwZUNoZWNrZXIuYXBwbHkodm9pZCAwLCBbcHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgXCJbXCIgKyBpICsgXCJdXCJdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxudmFyIG9ic2VydmFibGVBcnJheSA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlVHlwZUNoZWNrZXJDcmVhdG9yKGZhbHNlLCBcIkFycmF5XCIpO1xudmFyIG9ic2VydmFibGVBcnJheU9mID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBcnJheU9mVHlwZUNoZWNrZXIuYmluZChudWxsLCBmYWxzZSk7XG52YXIgb2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlVHlwZUNoZWNrZXJDcmVhdG9yKGZhbHNlLCBcIk1hcFwiKTtcbnZhciBvYnNlcnZhYmxlT2JqZWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IoZmFsc2UsIFwiT2JqZWN0XCIpO1xudmFyIGFycmF5T3JPYnNlcnZhYmxlQXJyYXkgPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcih0cnVlLCBcIkFycmF5XCIpO1xudmFyIGFycmF5T3JPYnNlcnZhYmxlQXJyYXlPZiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQXJyYXlPZlR5cGVDaGVja2VyLmJpbmQobnVsbCwgdHJ1ZSk7XG52YXIgb2JqZWN0T3JPYnNlcnZhYmxlT2JqZWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IodHJ1ZSwgXCJPYmplY3RcIik7XG52YXIgUHJvcFR5cGVzID0ge1xuICBvYnNlcnZhYmxlQXJyYXk6IG9ic2VydmFibGVBcnJheSxcbiAgb2JzZXJ2YWJsZUFycmF5T2Y6IG9ic2VydmFibGVBcnJheU9mLFxuICBvYnNlcnZhYmxlTWFwOiBvYnNlcnZhYmxlTWFwLFxuICBvYnNlcnZhYmxlT2JqZWN0OiBvYnNlcnZhYmxlT2JqZWN0LFxuICBhcnJheU9yT2JzZXJ2YWJsZUFycmF5OiBhcnJheU9yT2JzZXJ2YWJsZUFycmF5LFxuICBhcnJheU9yT2JzZXJ2YWJsZUFycmF5T2Y6IGFycmF5T3JPYnNlcnZhYmxlQXJyYXlPZixcbiAgb2JqZWN0T3JPYnNlcnZhYmxlT2JqZWN0OiBvYmplY3RPck9ic2VydmFibGVPYmplY3Rcbn07XG5cbmlmICghUmVhY3QuQ29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJtb2J4LXJlYWN0IHJlcXVpcmVzIFJlYWN0IHRvIGJlIGF2YWlsYWJsZVwiKTtcbmlmICghbW9ieC5vYnNlcnZhYmxlKSB0aHJvdyBuZXcgRXJyb3IoXCJtb2J4LXJlYWN0IHJlcXVpcmVzIG1vYnggdG8gYmUgYXZhaWxhYmxlXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ09ic2VydmVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2J4UmVhY3RMaXRlLk9ic2VydmVyO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdlbmFibGVTdGF0aWNSZW5kZXJpbmcnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vYnhSZWFjdExpdGUuZW5hYmxlU3RhdGljUmVuZGVyaW5nO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc1VzaW5nU3RhdGljUmVuZGVyaW5nJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2J4UmVhY3RMaXRlLmlzVXNpbmdTdGF0aWNSZW5kZXJpbmc7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ29ic2VydmVyQmF0Y2hpbmcnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vYnhSZWFjdExpdGUub2JzZXJ2ZXJCYXRjaGluZztcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlQXNPYnNlcnZhYmxlU291cmNlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2J4UmVhY3RMaXRlLnVzZUFzT2JzZXJ2YWJsZVNvdXJjZTtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlTG9jYWxPYnNlcnZhYmxlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2J4UmVhY3RMaXRlLnVzZUxvY2FsT2JzZXJ2YWJsZTtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlTG9jYWxTdG9yZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9ieFJlYWN0TGl0ZS51c2VMb2NhbFN0b3JlO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VPYnNlcnZlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9ieFJlYWN0TGl0ZS51c2VPYnNlcnZlcjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlU3RhdGljUmVuZGVyaW5nJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2J4UmVhY3RMaXRlLnVzZVN0YXRpY1JlbmRlcmluZztcbiAgICB9XG59KTtcbmV4cG9ydHMuTW9iWFByb3ZpZGVyQ29udGV4dCA9IE1vYlhQcm92aWRlckNvbnRleHQ7XG5leHBvcnRzLlByb3BUeXBlcyA9IFByb3BUeXBlcztcbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcbmV4cG9ydHMuZGlzcG9zZU9uVW5tb3VudCA9IGRpc3Bvc2VPblVubW91bnQ7XG5leHBvcnRzLmluamVjdCA9IGluamVjdDtcbmV4cG9ydHMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYnhyZWFjdC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx-react/dist/mobxreact.cjs.development.js\n");

/***/ })

};
;