"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mobx-react-lite";
exports.ids = ["vendor-chunks/mobx-react-lite"];
exports.modules = {

/***/ "(ssr)/./node_modules/mobx-react-lite/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mobx-react-lite/dist/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./mobxreactlite.cjs.development.js */ \"(ssr)/./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUNZOztBQUVaLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0SkFBOEQ7QUFDaEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYWJyaWMtdmlkZW8tZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9kaXN0L2luZGV4LmpzPzA2YjgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vYnhyZWFjdGxpdGUuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2J4cmVhY3RsaXRlLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx-react-lite/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar mobx = __webpack_require__(/*! mobx */ \"(ssr)/./node_modules/mobx/dist/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\nif (!React.useState) {\n  throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!mobx.makeObservable) {\n  throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n\nfunction defaultNoopBatch(callback) {\n  callback();\n}\nfunction observerBatching(reactionScheduler) {\n  if (!reactionScheduler) {\n    reactionScheduler = defaultNoopBatch;\n    {\n      console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n    }\n  }\n  mobx.configure({\n    reactionScheduler: reactionScheduler\n  });\n}\nvar isObserverBatched = function isObserverBatched() {\n  {\n    console.warn(\"[MobX] Deprecated\");\n  }\n  return true;\n};\n\nvar deprecatedMessages = [];\nfunction useDeprecated(msg) {\n  if (!deprecatedMessages.includes(msg)) {\n    deprecatedMessages.push(msg);\n    console.warn(msg);\n  }\n}\n\nfunction printDebugValue(v) {\n  return mobx.getDependencyTree(v);\n}\n\nvar REGISTRY_FINALIZE_AFTER = 10000;\nvar REGISTRY_SWEEP_INTERVAL = 10000;\nvar TimerBasedFinalizationRegistry = /*#__PURE__*/function () {\n  function TimerBasedFinalizationRegistry(finalize) {\n    var _this = this;\n    this.finalize = void 0;\n    this.registrations = new Map();\n    this.sweepTimeout = void 0;\n    this.sweep = function (maxAge) {\n      if (maxAge === void 0) {\n        maxAge = REGISTRY_FINALIZE_AFTER;\n      }\n      // cancel timeout so we can force sweep anytime\n      clearTimeout(_this.sweepTimeout);\n      _this.sweepTimeout = undefined;\n      var now = Date.now();\n      _this.registrations.forEach(function (registration, token) {\n        if (now - registration.registeredAt >= maxAge) {\n          _this.finalize(registration.value);\n          _this.registrations[\"delete\"](token);\n        }\n      });\n      if (_this.registrations.size > 0) {\n        _this.scheduleSweep();\n      }\n    };\n    this.finalizeAllImmediately = function () {\n      _this.sweep(0);\n    };\n    this.finalize = finalize;\n  }\n  // Token is actually required with this impl\n  var _proto = TimerBasedFinalizationRegistry.prototype;\n  _proto.register = function register(target, value, token) {\n    this.registrations.set(token, {\n      value: value,\n      registeredAt: Date.now()\n    });\n    this.scheduleSweep();\n  };\n  _proto.unregister = function unregister(token) {\n    this.registrations[\"delete\"](token);\n  }\n  // Bound so it can be used directly as setTimeout callback.\n  ;\n  _proto.scheduleSweep = function scheduleSweep() {\n    if (this.sweepTimeout === undefined) {\n      this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);\n    }\n  };\n  return TimerBasedFinalizationRegistry;\n}();\nvar UniversalFinalizationRegistry = typeof FinalizationRegistry !== \"undefined\" ? FinalizationRegistry : TimerBasedFinalizationRegistry;\n\nvar observerFinalizationRegistry = /*#__PURE__*/new UniversalFinalizationRegistry(function (adm) {\n  var _adm$reaction;\n  (_adm$reaction = adm.reaction) == null ? void 0 : _adm$reaction.dispose();\n  adm.reaction = null;\n});\n\nvar globalIsUsingStaticRendering = false;\nfunction enableStaticRendering(enable) {\n  globalIsUsingStaticRendering = enable;\n}\nfunction isUsingStaticRendering() {\n  return globalIsUsingStaticRendering;\n}\n\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\" + baseComponentName;\n}\n/**\r\n * We use class to make it easier to detect in heap snapshots by name\r\n */\nvar ObjectToBeRetainedByReact = function ObjectToBeRetainedByReact() {};\nfunction objectToBeRetainedByReactFactory() {\n  return new ObjectToBeRetainedByReact();\n}\nfunction useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n  var _React$useState = React__default.useState(objectToBeRetainedByReactFactory),\n    objectRetainedByReact = _React$useState[0];\n  // Force update, see #2982\n  var _React$useState2 = React__default.useState(),\n    setState = _React$useState2[1];\n  var forceUpdate = function forceUpdate() {\n    return setState([]);\n  };\n  // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n  var admRef = React__default.useRef(null);\n  if (!admRef.current) {\n    // First render\n    admRef.current = {\n      reaction: null,\n      mounted: false,\n      changedBeforeMount: false\n    };\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or component was not committed and reaction was disposed by registry\n    adm.reaction = new mobx.Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (adm.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.\n        adm.changedBeforeMount = true;\n      }\n    });\n    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);\n  }\n  React__default.useDebugValue(adm.reaction, printDebugValue);\n  React__default.useEffect(function () {\n    observerFinalizationRegistry.unregister(adm);\n    adm.mounted = true;\n    if (adm.reaction) {\n      if (adm.changedBeforeMount) {\n        // Got a change before mount, force an update\n        adm.changedBeforeMount = false;\n        forceUpdate();\n      }\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This can be due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up\n      // Re-create the reaction\n      adm.reaction = new mobx.Reaction(observerComponentNameFor(baseComponentName), function () {\n        // We've definitely already been mounted at this point\n        forceUpdate();\n      });\n      forceUpdate();\n    }\n    return function () {\n      adm.reaction.dispose();\n      adm.reaction = null;\n      adm.mounted = false;\n      adm.changedBeforeMount = false;\n    };\n  }, []);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var rendering;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}\n\nvar warnObserverOptionsDeprecated = true;\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nvar ReactForwardRefSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.forward_ref\") : typeof React.forwardRef === \"function\" && /*#__PURE__*/React.forwardRef(function (props) {\n  return null;\n})[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.memo\") : typeof React.memo === \"function\" && /*#__PURE__*/React.memo(function (props) {\n  return null;\n})[\"$$typeof\"];\n// n.b. base case is not used for actual typings or exported in the typing files\nfunction observer(baseComponent,\n// TODO remove in next major\noptions) {\n  var _options$forwardRef;\n  if ( warnObserverOptionsDeprecated && options) {\n    warnObserverOptionsDeprecated = false;\n    console.warn(\"[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`\");\n  }\n  if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n    throw new Error(\"[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.\");\n  }\n  // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n  if (isUsingStaticRendering()) {\n    return baseComponent;\n  }\n  var useForwardRef = (_options$forwardRef = options == null ? void 0 : options.forwardRef) != null ? _options$forwardRef : false;\n  var render = baseComponent;\n  var baseComponentName = baseComponent.displayName || baseComponent.name;\n  // If already wrapped with forwardRef, unwrap,\n  // so we can patch render and apply memo\n  if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n    useForwardRef = true;\n    render = baseComponent[\"render\"];\n    if (typeof render !== \"function\") {\n      throw new Error(\"[mobx-react-lite] `render` property of ForwardRef was not a function\");\n    }\n  }\n  var observerComponent = function observerComponent(props, ref) {\n    return useObserver(function () {\n      return render(props, ref);\n    }, baseComponentName);\n  };\n  // Don't set `displayName` for anonymous components,\n  // so the `displayName` can be customized by user, see #3192.\n  if (baseComponentName !== \"\") {\n    observerComponent.displayName = baseComponentName;\n  }\n  // Support legacy context: `contextTypes` must be applied before `memo`\n  if (baseComponent.contextTypes) {\n    observerComponent.contextTypes = baseComponent.contextTypes;\n  }\n  if (useForwardRef) {\n    // `forwardRef` must be applied prior `memo`\n    // `forwardRef(observer(cmp))` throws:\n    // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n    observerComponent = React.forwardRef(observerComponent);\n  }\n  // memo; we are not interested in deep updates\n  // in props; we assume that if deep objects are changed,\n  // this is in observables, which would have been tracked anyway\n  observerComponent = React.memo(observerComponent);\n  copyStaticProperties(baseComponent, observerComponent);\n  {\n    Object.defineProperty(observerComponent, \"contextTypes\", {\n      set: function set() {\n        var _this$type;\n        throw new Error(\"[mobx-react-lite] `\" + (this.displayName || ((_this$type = this.type) == null ? void 0 : _this$type.displayName) || \"Component\") + \".contextTypes` must be set before applying `observer`.\");\n      }\n    });\n  }\n  return observerComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n  $$typeof: true,\n  render: true,\n  compare: true,\n  type: true,\n  // Don't redefine `displayName`,\n  // it's defined as getter-setter pair on `memo` (see #3192).\n  displayName: true\n};\nfunction copyStaticProperties(base, target) {\n  Object.keys(base).forEach(function (key) {\n    if (!hoistBlackList[key]) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n\nfunction ObserverComponent(_ref) {\n  var children = _ref.children,\n    render = _ref.render;\n  var component = children || render;\n  if (typeof component !== \"function\") {\n    return null;\n  }\n  return useObserver(component);\n}\n{\n  ObserverComponent.propTypes = {\n    children: ObserverPropsCheck,\n    render: ObserverPropsCheck\n  };\n}\nObserverComponent.displayName = \"Observer\";\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n  var extraKey = key === \"children\" ? \"render\" : \"children\";\n  var hasProp = typeof props[key] === \"function\";\n  var hasExtraProp = typeof props[extraKey] === \"function\";\n  if (hasProp && hasExtraProp) {\n    return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n  }\n  if (hasProp || hasExtraProp) {\n    return null;\n  }\n  return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + typeof props[key] + \"` supplied to\" + \" `\" + componentName + \"`, expected `function`.\");\n}\n\nfunction useLocalObservable(initializer, annotations) {\n  return React.useState(function () {\n    return mobx.observable(initializer(), annotations, {\n      autoBind: true\n    });\n  })[0];\n}\n\nfunction useAsObservableSource(current) {\n  useDeprecated(\"[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.\");\n  var _useState = React.useState(function () {\n      return mobx.observable(current, {}, {\n        deep: false\n      });\n    }),\n    res = _useState[0];\n  mobx.runInAction(function () {\n    Object.assign(res, current);\n  });\n  return res;\n}\n\nfunction useLocalStore(initializer, current) {\n  useDeprecated(\"[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.\");\n  var source = current && useAsObservableSource(current);\n  return React.useState(function () {\n    return mobx.observable(initializer(source), undefined, {\n      autoBind: true\n    });\n  })[0];\n}\n\nvar _observerFinalization;\nobserverBatching(reactDom.unstable_batchedUpdates);\nvar clearTimers = (_observerFinalization = observerFinalizationRegistry[\"finalizeAllImmediately\"]) != null ? _observerFinalization : function () {};\nfunction useObserver$1(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  {\n    useDeprecated(\"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\");\n  }\n  return useObserver(fn, baseComponentName);\n}\nfunction useStaticRendering(enable) {\n  {\n    console.warn(\"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\");\n  }\n  enableStaticRendering(enable);\n}\n\nexports.Observer = ObserverComponent;\nexports.clearTimers = clearTimers;\nexports.enableStaticRendering = enableStaticRendering;\nexports.isObserverBatched = isObserverBatched;\nexports.isUsingStaticRendering = isUsingStaticRendering;\nexports.observer = observer;\nexports.observerBatching = observerBatching;\nexports.useAsObservableSource = useAsObservableSource;\nexports.useLocalObservable = useLocalObservable;\nexports.useLocalStore = useLocalStore;\nexports.useObserver = useObserver$1;\nexports.useStaticRendering = useStaticRendering;\n//# sourceMappingURL=mobxreactlite.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2Rpc3QvbW9ieHJlYWN0bGl0ZS5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQ0FBZ0M7O0FBRWhDLFdBQVcsbUJBQU8sQ0FBQyxxREFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0I7QUFDQSxlQUFlLG1CQUFPLENBQUMsZ0hBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixHQUFHO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhYnJpYy12aWRlby1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2Rpc3QvbW9ieHJlYWN0bGl0ZS5janMuZGV2ZWxvcG1lbnQuanM/ZTNkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgbW9ieCA9IHJlcXVpcmUoJ21vYngnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIHJlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbmlmICghUmVhY3QudXNlU3RhdGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibW9ieC1yZWFjdC1saXRlIHJlcXVpcmVzIFJlYWN0IHdpdGggSG9va3Mgc3VwcG9ydFwiKTtcbn1cbmlmICghbW9ieC5tYWtlT2JzZXJ2YWJsZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJtb2J4LXJlYWN0LWxpdGVAMyByZXF1aXJlcyBtb2J4IGF0IGxlYXN0IHZlcnNpb24gNiB0byBiZSBhdmFpbGFibGVcIik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVyQmF0Y2hpbmcocmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgaWYgKCFyZWFjdGlvblNjaGVkdWxlcikge1xuICAgIHJlYWN0aW9uU2NoZWR1bGVyID0gZGVmYXVsdE5vb3BCYXRjaDtcbiAgICB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gRmFpbGVkIHRvIGdldCB1bnN0YWJsZV9iYXRjaGVkIHVwZGF0ZXMgZnJvbSByZWFjdC1kb20gLyByZWFjdC1uYXRpdmVcIik7XG4gICAgfVxuICB9XG4gIG1vYnguY29uZmlndXJlKHtcbiAgICByZWFjdGlvblNjaGVkdWxlcjogcmVhY3Rpb25TY2hlZHVsZXJcbiAgfSk7XG59XG52YXIgaXNPYnNlcnZlckJhdGNoZWQgPSBmdW5jdGlvbiBpc09ic2VydmVyQmF0Y2hlZCgpIHtcbiAge1xuICAgIGNvbnNvbGUud2FybihcIltNb2JYXSBEZXByZWNhdGVkXCIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGRlcHJlY2F0ZWRNZXNzYWdlcyA9IFtdO1xuZnVuY3Rpb24gdXNlRGVwcmVjYXRlZChtc2cpIHtcbiAgaWYgKCFkZXByZWNhdGVkTWVzc2FnZXMuaW5jbHVkZXMobXNnKSkge1xuICAgIGRlcHJlY2F0ZWRNZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnREZWJ1Z1ZhbHVlKHYpIHtcbiAgcmV0dXJuIG1vYnguZ2V0RGVwZW5kZW5jeVRyZWUodik7XG59XG5cbnZhciBSRUdJU1RSWV9GSU5BTElaRV9BRlRFUiA9IDEwMDAwO1xudmFyIFJFR0lTVFJZX1NXRUVQX0lOVEVSVkFMID0gMTAwMDA7XG52YXIgVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5KGZpbmFsaXplKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmZpbmFsaXplID0gdm9pZCAwO1xuICAgIHRoaXMucmVnaXN0cmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnN3ZWVwVGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnN3ZWVwID0gZnVuY3Rpb24gKG1heEFnZSkge1xuICAgICAgaWYgKG1heEFnZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1heEFnZSA9IFJFR0lTVFJZX0ZJTkFMSVpFX0FGVEVSO1xuICAgICAgfVxuICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgc28gd2UgY2FuIGZvcmNlIHN3ZWVwIGFueXRpbWVcbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5zd2VlcFRpbWVvdXQpO1xuICAgICAgX3RoaXMuc3dlZXBUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICBfdGhpcy5yZWdpc3RyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbiwgdG9rZW4pIHtcbiAgICAgICAgaWYgKG5vdyAtIHJlZ2lzdHJhdGlvbi5yZWdpc3RlcmVkQXQgPj0gbWF4QWdlKSB7XG4gICAgICAgICAgX3RoaXMuZmluYWxpemUocmVnaXN0cmF0aW9uLnZhbHVlKTtcbiAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25zW1wiZGVsZXRlXCJdKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoX3RoaXMucmVnaXN0cmF0aW9ucy5zaXplID4gMCkge1xuICAgICAgICBfdGhpcy5zY2hlZHVsZVN3ZWVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmZpbmFsaXplQWxsSW1tZWRpYXRlbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zd2VlcCgwKTtcbiAgICB9O1xuICAgIHRoaXMuZmluYWxpemUgPSBmaW5hbGl6ZTtcbiAgfVxuICAvLyBUb2tlbiBpcyBhY3R1YWxseSByZXF1aXJlZCB3aXRoIHRoaXMgaW1wbFxuICB2YXIgX3Byb3RvID0gVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5LnByb3RvdHlwZTtcbiAgX3Byb3RvLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIodGFyZ2V0LCB2YWx1ZSwgdG9rZW4pIHtcbiAgICB0aGlzLnJlZ2lzdHJhdGlvbnMuc2V0KHRva2VuLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICByZWdpc3RlcmVkQXQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICB0aGlzLnNjaGVkdWxlU3dlZXAoKTtcbiAgfTtcbiAgX3Byb3RvLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKHRva2VuKSB7XG4gICAgdGhpcy5yZWdpc3RyYXRpb25zW1wiZGVsZXRlXCJdKHRva2VuKTtcbiAgfVxuICAvLyBCb3VuZCBzbyBpdCBjYW4gYmUgdXNlZCBkaXJlY3RseSBhcyBzZXRUaW1lb3V0IGNhbGxiYWNrLlxuICA7XG4gIF9wcm90by5zY2hlZHVsZVN3ZWVwID0gZnVuY3Rpb24gc2NoZWR1bGVTd2VlcCgpIHtcbiAgICBpZiAodGhpcy5zd2VlcFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zd2VlcFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuc3dlZXAsIFJFR0lTVFJZX1NXRUVQX0lOVEVSVkFMKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnk7XG59KCk7XG52YXIgVW5pdmVyc2FsRmluYWxpemF0aW9uUmVnaXN0cnkgPSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09IFwidW5kZWZpbmVkXCIgPyBGaW5hbGl6YXRpb25SZWdpc3RyeSA6IFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeTtcblxudmFyIG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovbmV3IFVuaXZlcnNhbEZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uIChhZG0pIHtcbiAgdmFyIF9hZG0kcmVhY3Rpb247XG4gIChfYWRtJHJlYWN0aW9uID0gYWRtLnJlYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2FkbSRyZWFjdGlvbi5kaXNwb3NlKCk7XG4gIGFkbS5yZWFjdGlvbiA9IG51bGw7XG59KTtcblxudmFyIGdsb2JhbElzVXNpbmdTdGF0aWNSZW5kZXJpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuYWJsZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpIHtcbiAgZ2xvYmFsSXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9IGVuYWJsZTtcbn1cbmZ1bmN0aW9uIGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcoKSB7XG4gIHJldHVybiBnbG9iYWxJc1VzaW5nU3RhdGljUmVuZGVyaW5nO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlckNvbXBvbmVudE5hbWVGb3IoYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgcmV0dXJuIFwib2JzZXJ2ZXJcIiArIGJhc2VDb21wb25lbnROYW1lO1xufVxuLyoqXHJcbiAqIFdlIHVzZSBjbGFzcyB0byBtYWtlIGl0IGVhc2llciB0byBkZXRlY3QgaW4gaGVhcCBzbmFwc2hvdHMgYnkgbmFtZVxyXG4gKi9cbnZhciBPYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0ID0gZnVuY3Rpb24gT2JqZWN0VG9CZVJldGFpbmVkQnlSZWFjdCgpIHt9O1xuZnVuY3Rpb24gb2JqZWN0VG9CZVJldGFpbmVkQnlSZWFjdEZhY3RvcnkoKSB7XG4gIHJldHVybiBuZXcgT2JqZWN0VG9CZVJldGFpbmVkQnlSZWFjdCgpO1xufVxuZnVuY3Rpb24gdXNlT2JzZXJ2ZXIoZm4sIGJhc2VDb21wb25lbnROYW1lKSB7XG4gIGlmIChiYXNlQ29tcG9uZW50TmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZUNvbXBvbmVudE5hbWUgPSBcIm9ic2VydmVkXCI7XG4gIH1cbiAgaWYgKGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcoKSkge1xuICAgIHJldHVybiBmbigpO1xuICB9XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShvYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0RmFjdG9yeSksXG4gICAgb2JqZWN0UmV0YWluZWRCeVJlYWN0ID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuICAvLyBGb3JjZSB1cGRhdGUsIHNlZSAjMjk4MlxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKCksXG4gICAgc2V0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICB2YXIgZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICByZXR1cm4gc2V0U3RhdGUoW10pO1xuICB9O1xuICAvLyBTdHJpY3RNb2RlL0NvbmN1cnJlbnRNb2RlL1N1c3BlbnNlIG1heSBtZWFuIHRoYXQgb3VyIGNvbXBvbmVudCBpc1xuICAvLyByZW5kZXJlZCBhbmQgYWJhbmRvbmVkIG11bHRpcGxlIHRpbWVzLCBzbyB3ZSBuZWVkIHRvIHRyYWNrIGxlYWtlZFxuICAvLyBSZWFjdGlvbnMuXG4gIHZhciBhZG1SZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gIGlmICghYWRtUmVmLmN1cnJlbnQpIHtcbiAgICAvLyBGaXJzdCByZW5kZXJcbiAgICBhZG1SZWYuY3VycmVudCA9IHtcbiAgICAgIHJlYWN0aW9uOiBudWxsLFxuICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICBjaGFuZ2VkQmVmb3JlTW91bnQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICB2YXIgYWRtID0gYWRtUmVmLmN1cnJlbnQ7XG4gIGlmICghYWRtLnJlYWN0aW9uKSB7XG4gICAgLy8gRmlyc3QgcmVuZGVyIG9yIGNvbXBvbmVudCB3YXMgbm90IGNvbW1pdHRlZCBhbmQgcmVhY3Rpb24gd2FzIGRpc3Bvc2VkIGJ5IHJlZ2lzdHJ5XG4gICAgYWRtLnJlYWN0aW9uID0gbmV3IG1vYnguUmVhY3Rpb24ob2JzZXJ2ZXJDb21wb25lbnROYW1lRm9yKGJhc2VDb21wb25lbnROYW1lKSwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gT2JzZXJ2YWJsZSBoYXMgY2hhbmdlZCwgbWVhbmluZyB3ZSB3YW50IHRvIHJlLXJlbmRlclxuICAgICAgLy8gQlVUIGlmIHdlJ3JlIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IHlldCBnb3QgdG8gdGhlIHVzZUVmZmVjdCgpXG4gICAgICAvLyBzdGFnZSwgd2UgbWlnaHQgYmUgYSBjb21wb25lbnQgdGhhdCBfc3RhcnRlZF8gdG8gcmVuZGVyLCBidXRcbiAgICAgIC8vIGdvdCBkcm9wcGVkLCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHN0YXRlIGNoYW5nZXMgdGhlbi5cbiAgICAgIC8vIChJdCB0cmlnZ2VycyB3YXJuaW5ncyBpbiBTdHJpY3RNb2RlLCBmb3IgYSBzdGFydC4pXG4gICAgICBpZiAoYWRtLm1vdW50ZWQpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHVzZUVmZmVjdCgpLCBzbyB3ZSdyZSBtb3VudGVkLCBhbmQgY2FuIHRyaWdnZXIgYW4gdXBkYXRlXG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlbid0IHlldCByZWFjaGVkIHVzZUVmZmVjdCgpLCBzbyB3ZSdsbCBuZWVkIHRvIHRyaWdnZXIgYSByZS1yZW5kZXJcbiAgICAgICAgLy8gd2hlbiAoYW5kIGlmKSB1c2VFZmZlY3QoKSBhcnJpdmVzLlxuICAgICAgICBhZG0uY2hhbmdlZEJlZm9yZU1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKG9iamVjdFJldGFpbmVkQnlSZWFjdCwgYWRtLCBhZG0pO1xuICB9XG4gIFJlYWN0X19kZWZhdWx0LnVzZURlYnVnVmFsdWUoYWRtLnJlYWN0aW9uLCBwcmludERlYnVnVmFsdWUpO1xuICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkudW5yZWdpc3RlcihhZG0pO1xuICAgIGFkbS5tb3VudGVkID0gdHJ1ZTtcbiAgICBpZiAoYWRtLnJlYWN0aW9uKSB7XG4gICAgICBpZiAoYWRtLmNoYW5nZWRCZWZvcmVNb3VudCkge1xuICAgICAgICAvLyBHb3QgYSBjaGFuZ2UgYmVmb3JlIG1vdW50LCBmb3JjZSBhbiB1cGRhdGVcbiAgICAgICAgYWRtLmNoYW5nZWRCZWZvcmVNb3VudCA9IGZhbHNlO1xuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmVhY3Rpb24gd2Ugc2V0IHVwIGluIG91ciByZW5kZXIgaGFzIGJlZW4gZGlzcG9zZWQuXG4gICAgICAvLyBUaGlzIGNhbiBiZSBkdWUgdG8gYmFkIHRpbWluZ3Mgb2YgcmVuZGVyaW5ncywgZS5nLiBvdXJcbiAgICAgIC8vIGNvbXBvbmVudCB3YXMgcGF1c2VkIGZvciBhIF92ZXJ5XyBsb25nIHRpbWUsIGFuZCBvdXJcbiAgICAgIC8vIHJlYWN0aW9uIGdvdCBjbGVhbmVkIHVwXG4gICAgICAvLyBSZS1jcmVhdGUgdGhlIHJlYWN0aW9uXG4gICAgICBhZG0ucmVhY3Rpb24gPSBuZXcgbW9ieC5SZWFjdGlvbihvYnNlcnZlckNvbXBvbmVudE5hbWVGb3IoYmFzZUNvbXBvbmVudE5hbWUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGRlZmluaXRlbHkgYWxyZWFkeSBiZWVuIG1vdW50ZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgYWRtLnJlYWN0aW9uLmRpc3Bvc2UoKTtcbiAgICAgIGFkbS5yZWFjdGlvbiA9IG51bGw7XG4gICAgICBhZG0ubW91bnRlZCA9IGZhbHNlO1xuICAgICAgYWRtLmNoYW5nZWRCZWZvcmVNb3VudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgLy8gcmVuZGVyIHRoZSBvcmlnaW5hbCBjb21wb25lbnQsIGJ1dCBoYXZlIHRoZVxuICAvLyByZWFjdGlvbiB0cmFjayB0aGUgb2JzZXJ2YWJsZXMsIHNvIHRoYXQgcmVuZGVyaW5nXG4gIC8vIGNhbiBiZSBpbnZhbGlkYXRlZCAoc2VlIGFib3ZlKSBvbmNlIGEgZGVwZW5kZW5jeSBjaGFuZ2VzXG4gIHZhciByZW5kZXJpbmc7XG4gIHZhciBleGNlcHRpb247XG4gIGFkbS5yZWFjdGlvbi50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlcmluZyA9IGZuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgdGhyb3cgZXhjZXB0aW9uOyAvLyByZS10aHJvdyBhbnkgZXhjZXB0aW9ucyBjYXVnaHQgZHVyaW5nIHJlbmRlcmluZ1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmluZztcbn1cblxudmFyIHdhcm5PYnNlcnZlck9wdGlvbnNEZXByZWNhdGVkID0gdHJ1ZTtcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sW1wiZm9yXCJdO1xuLy8gVXNpbmcgcmVhY3QtaXMgaGFkIHNvbWUgaXNzdWVzIChhbmQgb3BlcmF0ZXMgb24gZWxlbWVudHMsIG5vdCBvbiB0eXBlcyksIHNlZSAjNjA4IC8gIzYwOVxudmFyIFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCA9IGhhc1N5bWJvbCA/IC8qI19fUFVSRV9fKi9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IHR5cGVvZiBSZWFjdC5mb3J3YXJkUmVmID09PSBcImZ1bmN0aW9uXCIgJiYgLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBudWxsO1xufSlbXCIkJHR5cGVvZlwiXTtcbnZhciBSZWFjdE1lbW9TeW1ib2wgPSBoYXNTeW1ib2wgPyAvKiNfX1BVUkVfXyovU3ltYm9sW1wiZm9yXCJdKFwicmVhY3QubWVtb1wiKSA6IHR5cGVvZiBSZWFjdC5tZW1vID09PSBcImZ1bmN0aW9uXCIgJiYgLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBudWxsO1xufSlbXCIkJHR5cGVvZlwiXTtcbi8vIG4uYi4gYmFzZSBjYXNlIGlzIG5vdCB1c2VkIGZvciBhY3R1YWwgdHlwaW5ncyBvciBleHBvcnRlZCBpbiB0aGUgdHlwaW5nIGZpbGVzXG5mdW5jdGlvbiBvYnNlcnZlcihiYXNlQ29tcG9uZW50LFxuLy8gVE9ETyByZW1vdmUgaW4gbmV4dCBtYWpvclxub3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZm9yd2FyZFJlZjtcbiAgaWYgKCB3YXJuT2JzZXJ2ZXJPcHRpb25zRGVwcmVjYXRlZCAmJiBvcHRpb25zKSB7XG4gICAgd2Fybk9ic2VydmVyT3B0aW9uc0RlcHJlY2F0ZWQgPSBmYWxzZTtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieC1yZWFjdC1saXRlXSBgb2JzZXJ2ZXIoZm4sIHsgZm9yd2FyZFJlZjogdHJ1ZSB9KWAgaXMgZGVwcmVjYXRlZCwgdXNlIGBvYnNlcnZlcihSZWFjdC5mb3J3YXJkUmVmKGZuKSlgXCIpO1xuICB9XG4gIGlmIChSZWFjdE1lbW9TeW1ib2wgJiYgYmFzZUNvbXBvbmVudFtcIiQkdHlwZW9mXCJdID09PSBSZWFjdE1lbW9TeW1ib2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBZb3UgYXJlIHRyeWluZyB0byB1c2UgYG9ic2VydmVyYCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudCB3cmFwcGVkIGluIGVpdGhlciBhbm90aGVyIGBvYnNlcnZlcmAgb3IgYFJlYWN0Lm1lbW9gLiBUaGUgb2JzZXJ2ZXIgYWxyZWFkeSBhcHBsaWVzICdSZWFjdC5tZW1vJyBmb3IgeW91LlwiKTtcbiAgfVxuICAvLyBUaGUgd29ya2luZyBvZiBvYnNlcnZlciBpcyBleHBsYWluZWQgc3RlcCBieSBzdGVwIGluIHRoaXMgdGFsazogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1jUEY0aUJlZG9GMCZmZWF0dXJlPXlvdXR1LmJlJnQ9MTMwN1xuICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgcmV0dXJuIGJhc2VDb21wb25lbnQ7XG4gIH1cbiAgdmFyIHVzZUZvcndhcmRSZWYgPSAoX29wdGlvbnMkZm9yd2FyZFJlZiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yd2FyZFJlZikgIT0gbnVsbCA/IF9vcHRpb25zJGZvcndhcmRSZWYgOiBmYWxzZTtcbiAgdmFyIHJlbmRlciA9IGJhc2VDb21wb25lbnQ7XG4gIHZhciBiYXNlQ29tcG9uZW50TmFtZSA9IGJhc2VDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgYmFzZUNvbXBvbmVudC5uYW1lO1xuICAvLyBJZiBhbHJlYWR5IHdyYXBwZWQgd2l0aCBmb3J3YXJkUmVmLCB1bndyYXAsXG4gIC8vIHNvIHdlIGNhbiBwYXRjaCByZW5kZXIgYW5kIGFwcGx5IG1lbW9cbiAgaWYgKFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCAmJiBiYXNlQ29tcG9uZW50W1wiJCR0eXBlb2ZcIl0gPT09IFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCkge1xuICAgIHVzZUZvcndhcmRSZWYgPSB0cnVlO1xuICAgIHJlbmRlciA9IGJhc2VDb21wb25lbnRbXCJyZW5kZXJcIl07XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYngtcmVhY3QtbGl0ZV0gYHJlbmRlcmAgcHJvcGVydHkgb2YgRm9yd2FyZFJlZiB3YXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG4gIHZhciBvYnNlcnZlckNvbXBvbmVudCA9IGZ1bmN0aW9uIG9ic2VydmVyQ29tcG9uZW50KHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gdXNlT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlbmRlcihwcm9wcywgcmVmKTtcbiAgICB9LCBiYXNlQ29tcG9uZW50TmFtZSk7XG4gIH07XG4gIC8vIERvbid0IHNldCBgZGlzcGxheU5hbWVgIGZvciBhbm9ueW1vdXMgY29tcG9uZW50cyxcbiAgLy8gc28gdGhlIGBkaXNwbGF5TmFtZWAgY2FuIGJlIGN1c3RvbWl6ZWQgYnkgdXNlciwgc2VlICMzMTkyLlxuICBpZiAoYmFzZUNvbXBvbmVudE5hbWUgIT09IFwiXCIpIHtcbiAgICBvYnNlcnZlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGJhc2VDb21wb25lbnROYW1lO1xuICB9XG4gIC8vIFN1cHBvcnQgbGVnYWN5IGNvbnRleHQ6IGBjb250ZXh0VHlwZXNgIG11c3QgYmUgYXBwbGllZCBiZWZvcmUgYG1lbW9gXG4gIGlmIChiYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgIG9ic2VydmVyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IGJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICB9XG4gIGlmICh1c2VGb3J3YXJkUmVmKSB7XG4gICAgLy8gYGZvcndhcmRSZWZgIG11c3QgYmUgYXBwbGllZCBwcmlvciBgbWVtb2BcbiAgICAvLyBgZm9yd2FyZFJlZihvYnNlcnZlcihjbXApKWAgdGhyb3dzOlxuICAgIC8vIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKVwiXG4gICAgb2JzZXJ2ZXJDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKG9ic2VydmVyQ29tcG9uZW50KTtcbiAgfVxuICAvLyBtZW1vOyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gZGVlcCB1cGRhdGVzXG4gIC8vIGluIHByb3BzOyB3ZSBhc3N1bWUgdGhhdCBpZiBkZWVwIG9iamVjdHMgYXJlIGNoYW5nZWQsXG4gIC8vIHRoaXMgaXMgaW4gb2JzZXJ2YWJsZXMsIHdoaWNoIHdvdWxkIGhhdmUgYmVlbiB0cmFja2VkIGFueXdheVxuICBvYnNlcnZlckNvbXBvbmVudCA9IFJlYWN0Lm1lbW8ob2JzZXJ2ZXJDb21wb25lbnQpO1xuICBjb3B5U3RhdGljUHJvcGVydGllcyhiYXNlQ29tcG9uZW50LCBvYnNlcnZlckNvbXBvbmVudCk7XG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JzZXJ2ZXJDb21wb25lbnQsIFwiY29udGV4dFR5cGVzXCIsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkdHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYngtcmVhY3QtbGl0ZV0gYFwiICsgKHRoaXMuZGlzcGxheU5hbWUgfHwgKChfdGhpcyR0eXBlID0gdGhpcy50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHlwZS5kaXNwbGF5TmFtZSkgfHwgXCJDb21wb25lbnRcIikgKyBcIi5jb250ZXh0VHlwZXNgIG11c3QgYmUgc2V0IGJlZm9yZSBhcHBseWluZyBgb2JzZXJ2ZXJgLlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2JzZXJ2ZXJDb21wb25lbnQ7XG59XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbXJpZGd3YXkvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LmpzXG52YXIgaG9pc3RCbGFja0xpc3QgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIHR5cGU6IHRydWUsXG4gIC8vIERvbid0IHJlZGVmaW5lIGBkaXNwbGF5TmFtZWAsXG4gIC8vIGl0J3MgZGVmaW5lZCBhcyBnZXR0ZXItc2V0dGVyIHBhaXIgb24gYG1lbW9gIChzZWUgIzMxOTIpLlxuICBkaXNwbGF5TmFtZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNvcHlTdGF0aWNQcm9wZXJ0aWVzKGJhc2UsIHRhcmdldCkge1xuICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWhvaXN0QmxhY2tMaXN0W2tleV0pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBPYnNlcnZlckNvbXBvbmVudChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgcmVuZGVyID0gX3JlZi5yZW5kZXI7XG4gIHZhciBjb21wb25lbnQgPSBjaGlsZHJlbiB8fCByZW5kZXI7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdXNlT2JzZXJ2ZXIoY29tcG9uZW50KTtcbn1cbntcbiAgT2JzZXJ2ZXJDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBPYnNlcnZlclByb3BzQ2hlY2ssXG4gICAgcmVuZGVyOiBPYnNlcnZlclByb3BzQ2hlY2tcbiAgfTtcbn1cbk9ic2VydmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gXCJPYnNlcnZlclwiO1xuZnVuY3Rpb24gT2JzZXJ2ZXJQcm9wc0NoZWNrKHByb3BzLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIGV4dHJhS2V5ID0ga2V5ID09PSBcImNoaWxkcmVuXCIgPyBcInJlbmRlclwiIDogXCJjaGlsZHJlblwiO1xuICB2YXIgaGFzUHJvcCA9IHR5cGVvZiBwcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCI7XG4gIHZhciBoYXNFeHRyYVByb3AgPSB0eXBlb2YgcHJvcHNbZXh0cmFLZXldID09PSBcImZ1bmN0aW9uXCI7XG4gIGlmIChoYXNQcm9wICYmIGhhc0V4dHJhUHJvcCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJNb2JYIE9ic2VydmVyOiBEbyBub3QgdXNlIGNoaWxkcmVuIGFuZCByZW5kZXIgaW4gdGhlIHNhbWUgdGltZSBpbmBcIiArIGNvbXBvbmVudE5hbWUpO1xuICB9XG4gIGlmIChoYXNQcm9wIHx8IGhhc0V4dHJhUHJvcCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgdHlwZW9mIHByb3BzW2tleV0gKyBcImAgc3VwcGxpZWQgdG9cIiArIFwiIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBmdW5jdGlvbmAuXCIpO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbE9ic2VydmFibGUoaW5pdGlhbGl6ZXIsIGFubm90YXRpb25zKSB7XG4gIHJldHVybiBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1vYngub2JzZXJ2YWJsZShpbml0aWFsaXplcigpLCBhbm5vdGF0aW9ucywge1xuICAgICAgYXV0b0JpbmQ6IHRydWVcbiAgICB9KTtcbiAgfSlbMF07XG59XG5cbmZ1bmN0aW9uIHVzZUFzT2JzZXJ2YWJsZVNvdXJjZShjdXJyZW50KSB7XG4gIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlQXNPYnNlcnZhYmxlU291cmNlJyBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc3RvcmUgdGhlIHZhbHVlcyBkaXJlY3RseSBpbiBhbiBvYnNlcnZhYmxlLCBmb3IgZXhhbXBsZSBieSB1c2luZyAndXNlTG9jYWxPYnNlcnZhYmxlJywgYW5kIHN5bmMgZnV0dXJlIHVwZGF0ZXMgdXNpbmcgJ3VzZUVmZmVjdCcgd2hlbiBuZWVkZWQuIFNlZSB0aGUgUkVBRE1FIGZvciBleGFtcGxlcy5cIik7XG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbW9ieC5vYnNlcnZhYmxlKGN1cnJlbnQsIHt9LCB7XG4gICAgICAgIGRlZXA6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICByZXMgPSBfdXNlU3RhdGVbMF07XG4gIG1vYngucnVuSW5BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5hc3NpZ24ocmVzLCBjdXJyZW50KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHVzZUxvY2FsU3RvcmUoaW5pdGlhbGl6ZXIsIGN1cnJlbnQpIHtcbiAgdXNlRGVwcmVjYXRlZChcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VMb2NhbFN0b3JlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3VzZUxvY2FsT2JzZXJ2YWJsZScgaW5zdGVhZC5cIik7XG4gIHZhciBzb3VyY2UgPSBjdXJyZW50ICYmIHVzZUFzT2JzZXJ2YWJsZVNvdXJjZShjdXJyZW50KTtcbiAgcmV0dXJuIFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9ieC5vYnNlcnZhYmxlKGluaXRpYWxpemVyKHNvdXJjZSksIHVuZGVmaW5lZCwge1xuICAgICAgYXV0b0JpbmQ6IHRydWVcbiAgICB9KTtcbiAgfSlbMF07XG59XG5cbnZhciBfb2JzZXJ2ZXJGaW5hbGl6YXRpb247XG5vYnNlcnZlckJhdGNoaW5nKHJlYWN0RG9tLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKTtcbnZhciBjbGVhclRpbWVycyA9IChfb2JzZXJ2ZXJGaW5hbGl6YXRpb24gPSBvYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5W1wiZmluYWxpemVBbGxJbW1lZGlhdGVseVwiXSkgIT0gbnVsbCA/IF9vYnNlcnZlckZpbmFsaXphdGlvbiA6IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gdXNlT2JzZXJ2ZXIkMShmbiwgYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKGJhc2VDb21wb25lbnROYW1lID09PSB2b2lkIDApIHtcbiAgICBiYXNlQ29tcG9uZW50TmFtZSA9IFwib2JzZXJ2ZWRcIjtcbiAgfVxuICB7XG4gICAgdXNlRGVwcmVjYXRlZChcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VPYnNlcnZlcihmbiknIGlzIGRlcHJlY2F0ZWQuIFVzZSBgPE9ic2VydmVyPntmbn08L09ic2VydmVyPmAgaW5zdGVhZCwgb3Igd3JhcCB0aGUgZW50aXJlIGNvbXBvbmVudCBpbiBgb2JzZXJ2ZXJgLlwiKTtcbiAgfVxuICByZXR1cm4gdXNlT2JzZXJ2ZXIoZm4sIGJhc2VDb21wb25lbnROYW1lKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpIHtcbiAge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VTdGF0aWNSZW5kZXJpbmcnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnZW5hYmxlU3RhdGljUmVuZGVyaW5nJyBpbnN0ZWFkXCIpO1xuICB9XG4gIGVuYWJsZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpO1xufVxuXG5leHBvcnRzLk9ic2VydmVyID0gT2JzZXJ2ZXJDb21wb25lbnQ7XG5leHBvcnRzLmNsZWFyVGltZXJzID0gY2xlYXJUaW1lcnM7XG5leHBvcnRzLmVuYWJsZVN0YXRpY1JlbmRlcmluZyA9IGVuYWJsZVN0YXRpY1JlbmRlcmluZztcbmV4cG9ydHMuaXNPYnNlcnZlckJhdGNoZWQgPSBpc09ic2VydmVyQmF0Y2hlZDtcbmV4cG9ydHMuaXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9IGlzVXNpbmdTdGF0aWNSZW5kZXJpbmc7XG5leHBvcnRzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG5leHBvcnRzLm9ic2VydmVyQmF0Y2hpbmcgPSBvYnNlcnZlckJhdGNoaW5nO1xuZXhwb3J0cy51c2VBc09ic2VydmFibGVTb3VyY2UgPSB1c2VBc09ic2VydmFibGVTb3VyY2U7XG5leHBvcnRzLnVzZUxvY2FsT2JzZXJ2YWJsZSA9IHVzZUxvY2FsT2JzZXJ2YWJsZTtcbmV4cG9ydHMudXNlTG9jYWxTdG9yZSA9IHVzZUxvY2FsU3RvcmU7XG5leHBvcnRzLnVzZU9ic2VydmVyID0gdXNlT2JzZXJ2ZXIkMTtcbmV4cG9ydHMudXNlU3RhdGljUmVuZGVyaW5nID0gdXNlU3RhdGljUmVuZGVyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ieHJlYWN0bGl0ZS5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js\n");

/***/ })

};
;